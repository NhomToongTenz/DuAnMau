Index: Assets/Scripts/Items and Inventory/itemObj.cs.meta
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Items and Inventory/itemObj.cs.meta b/Assets/Scripts/Items and Inventory/itemObj.cs.meta
deleted file mode 100644
--- a/Assets/Scripts/Items and Inventory/itemObj.cs.meta	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ /dev/null	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
@@ -1,2 +0,0 @@
-fileFormatVersion: 2
-guid: a30a290bcf4bb4cd4814333ac4a6c149
\ No newline at end of file
Index: Assets/Scripts/UI/UI_CraftSlot.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/UI/UI_CraftSlot.cs b/Assets/Scripts/UI/UI_CraftSlot.cs
deleted file mode 100644
--- a/Assets/Scripts/UI/UI_CraftSlot.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ /dev/null	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
@@ -1,18 +0,0 @@
-using System;
-using UnityEngine;
-using UnityEngine.EventSystems;
-
-public class UI_CraftSlot : UI_ItemSlot
-{
-   private void OnEnable()
-   {
-      UpdateSlot(item);
-   }
-
-   public override void OnPointerDown(PointerEventData eventData)
-   {
-      ItemData_Equipment crafData = item.data as ItemData_Equipment;
-      Inventory.instance.CanCraft(crafData, crafData.craftingMaterials);
-      
-   }
-}
Index: Assets/Scripts/UI/UI_EquipmentSlot.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/UI/UI_EquipmentSlot.cs b/Assets/Scripts/UI/UI_EquipmentSlot.cs
deleted file mode 100644
--- a/Assets/Scripts/UI/UI_EquipmentSlot.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ /dev/null	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
@@ -1,25 +0,0 @@
-using System;
-using UnityEngine;
-using UnityEngine.EventSystems;
-
-public class UI_EquipmentSlot : UI_ItemSlot
-{
-   public EquipmentType  slotType;
-
-   private void OnValidate()
-   {
-      gameObject.name = "Equipment slot - " + slotType.ToString();
-   }
-
-   public override void OnPointerDown(PointerEventData eventData)
-   {  
-      
-      if(item == null || item.data == null)
-         return;
-      
-      Inventory.instance.UnEquipItem(item.data as ItemData_Equipment);
-      Inventory.instance.AddItem(item.data as ItemData_Equipment);
-      CleanUpSlot();
-     
-   }
-}
Index: Assets/Scripts/UI/UI_ItemSlot.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/UI/UI_ItemSlot.cs b/Assets/Scripts/UI/UI_ItemSlot.cs
deleted file mode 100644
--- a/Assets/Scripts/UI/UI_ItemSlot.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ /dev/null	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
@@ -1,82 +0,0 @@
-using System;
-using UnityEngine;
-using UnityEngine.UI;
-using TMPro;
-using UnityEngine.EventSystems;
-
-public class UI_ItemSlot : MonoBehaviour, IPointerDownHandler
-{
-    [SerializeField] private Image itemImage;
-    [SerializeField] private TextMeshProUGUI itemText;
-    
-    public InventoryItem item;
-    protected UI ui;
-
-    protected void Start()
-    {
-        ui = GetComponentInParent<UI>();
-    }
-
-
-    // Clear the slot 
-    public void CleanUpSlot()
-    {
-        item = null;
-        itemImage.color = Color.clear;
-        itemImage.sprite = null;
-        itemText.text = "";
-    }
-    
-    public void UpdateSlot(InventoryItem _newItem)
-    {
-        item = _newItem;
-        
-        itemImage.color = Color.white;
-        
-        if(item != null)
-        {
-            itemImage.sprite = item.data.itemIcon;
-            if (item.stackSize > 1)
-            {
-                itemText.text = item.stackSize.ToString();
-            }
-            else
-            {
-                itemText.text = "";
-            }
-            
-        }
-    }
-
-    public virtual void OnPointerDown(PointerEventData eventData)
-    {   
-        
-        //Debug.Log("Equipped " + item.data.itemName);
-        
-        if (item == null)
-            return;
-        
-        if (Input.GetKey(KeyCode.LeftControl))
-        {
-            Debug.Log("Removed " + item.data.itemName);
-            Inventory.instance.RemoveItem(item.data);
-            return;
-        }
-
-
-        if (item.data.itemType == ItemType.Equipment)
-        {
-            
-            //Invoke("EquipItem", 1f );
-            Inventory.instance.EquipItem(item.data);
-            Debug.Log("Equipped " + item.data.itemName);
-        }
-         
-    }
-    
-    public void EquipItem(ItemData item)
-    {
-        Inventory.instance.EquipItem(item);
-    }
-    
-}
Index: Assets/testOnPointerDown.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/testOnPointerDown.cs b/Assets/testOnPointerDown.cs
deleted file mode 100644
--- a/Assets/testOnPointerDown.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ /dev/null	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
@@ -1,23 +0,0 @@
-using UnityEngine;
-using UnityEngine.EventSystems;
-
-public class testOnPointerDown : MonoBehaviour
-{
-    // Start is called once before the first execution of Update after the MonoBehaviour is created
-    void Start()
-    {
-        
-    }
-
-    // Update is called once per frame
-    void Update()
-    {
-        
-    }
-    
-    public void OnPointerDown(PointerEventData eventData)
-    {
-        Debug.Log("OnPointerDown");
-    }
-    
-}
Index: Assets/testOnPointerDown.cs.meta
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/testOnPointerDown.cs.meta b/Assets/testOnPointerDown.cs.meta
deleted file mode 100644
--- a/Assets/testOnPointerDown.cs.meta	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ /dev/null	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
@@ -1,2 +0,0 @@
-fileFormatVersion: 2
-guid: 0c66ff49559084bec991e087bc594927
\ No newline at end of file
Index: Assets/Scripts/Items and Inventory/PlayerItemDrop.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerItemDrop : ItemDrop  \n{\n    [Header(\"Player Item Drop\")]\n    [SerializeField] private float chanceToLooseItem ;\n    [SerializeField] private float chanceToLooseMaterials;\n    public override void GenerateDrop()\n    {\n        Inventory inventory = Inventory.instance;\n    \n        List<InventoryItem> itemsToUnequip = new List<InventoryItem>();\n        List<InventoryItem> materialsToDrop = new List<InventoryItem>();\n        foreach (InventoryItem item in inventory.GetEquipmentList())\n        {\n            if(Random.Range(0, 100) <= chanceToLooseItem)\n            {\n                DropItem(item.data);\n                itemsToUnequip.Add(item);\n            }\n        }\n\n        for (int i = 0; i < itemsToUnequip.Count; i++)\n        {\n            inventory.UnEquipItem(itemsToUnequip[i].data as ItemData_Equipment);\n        }\n\n        foreach (var i in inventory.GetStashList())\n        {   \n            if(Random.Range(0, 100) <= chanceToLooseMaterials)\n            {\n                DropItem(i.data);\n                \n                materialsToDrop.Add(i);\n            }\n        }\n        \n        for(int i = 0; i < materialsToDrop.Count; i++)\n        {\n            inventory.RemoveItem(materialsToDrop[i].data);\n        }\n            \n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Items and Inventory/PlayerItemDrop.cs b/Assets/Scripts/Items and Inventory/PlayerItemDrop.cs
--- a/Assets/Scripts/Items and Inventory/PlayerItemDrop.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/Items and Inventory/PlayerItemDrop.cs	(date 1716917720355)
@@ -1,45 +1,51 @@
 using System.Collections.Generic;
 using UnityEngine;
 
-public class PlayerItemDrop : ItemDrop  
-{
-    [Header("Player Item Drop")]
-    [SerializeField] private float chanceToLooseItem ;
-    [SerializeField] private float chanceToLooseMaterials;
-    public override void GenerateDrop()
-    {
-        Inventory inventory = Inventory.instance;
-    
-        List<InventoryItem> itemsToUnequip = new List<InventoryItem>();
-        List<InventoryItem> materialsToDrop = new List<InventoryItem>();
-        foreach (InventoryItem item in inventory.GetEquipmentList())
-        {
-            if(Random.Range(0, 100) <= chanceToLooseItem)
-            {
-                DropItem(item.data);
-                itemsToUnequip.Add(item);
-            }
-        }
+namespace Items_and_Inventory
+{
+
+    public class PlayerItemDrop : ItemDrop
+    {
+        [Header("Player Item Drop")] [SerializeField]
+        private float chanceToLooseItem;
+
+        [SerializeField] private float chanceToLooseMaterials;
+
+        public override void GenerateDrop()
+        {
+            Inventory inventory = Inventory.Instance;
+
+            List<InventoryItem> itemsToUnequip = new List<InventoryItem>();
+            List<InventoryItem> materialsToDrop = new List<InventoryItem>();
+            foreach (InventoryItem item in inventory.GetEquipmentList())
+            {
+                if (Random.Range(0, 100) <= chanceToLooseItem)
+                {
+                    DropItem(item.data);
+                    itemsToUnequip.Add(item);
+                }
+            }
 
-        for (int i = 0; i < itemsToUnequip.Count; i++)
-        {
-            inventory.UnEquipItem(itemsToUnequip[i].data as ItemData_Equipment);
-        }
+            for (int i = 0; i < itemsToUnequip.Count; i++)
+            {
+                inventory.UnEquipItem(itemsToUnequip[i].data as ItemData_Equipment);
+            }
 
-        foreach (var i in inventory.GetStashList())
-        {   
-            if(Random.Range(0, 100) <= chanceToLooseMaterials)
-            {
-                DropItem(i.data);
-                
-                materialsToDrop.Add(i);
-            }
-        }
-        
-        for(int i = 0; i < materialsToDrop.Count; i++)
-        {
-            inventory.RemoveItem(materialsToDrop[i].data);
-        }
-            
-    }
-}
+            foreach (var i in inventory.GetStashList())
+            {
+                if (Random.Range(0, 100) <= chanceToLooseMaterials)
+                {
+                    DropItem(i.data);
+
+                    materialsToDrop.Add(i);
+                }
+            }
+
+            for (int i = 0; i < materialsToDrop.Count; i++)
+            {
+                inventory.RemoveItem(materialsToDrop[i].data);
+            }
+
+        }
+    }
+}
\ No newline at end of file
Index: Assets/Scripts/Items and Inventory/Inventory.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Serialization;\n\npublic class Inventory : MonoBehaviour\n{   \n    public static Inventory instance;\n    \n    public List<ItemData> startingEquipment;\n    \n    public List<InventoryItem> equipment;\n    public Dictionary<ItemData_Equipment, InventoryItem> equipmentDictionary;\n\n    public List<InventoryItem> inventory;\n    public Dictionary<ItemData, InventoryItem> inventoryDictionary;\n    \n    public List<InventoryItem> stashItems;\n    public Dictionary<ItemData, InventoryItem> stashDictionary;\n    \n    \n    [Header(\"Inventory UI\")]\n    \n    [SerializeField] private Transform inventorySlotParent;\n    [SerializeField] private Transform stashSlotParent;\n    [SerializeField] private Transform equipmentSlotParent;\n    [SerializeField] private Transform statSlotParent;\n    \n    \n    [Header(\"Items cooldown\")]\n    private float lastFlaskUsed;\n    private float lastArmorUsed;\n    \n    private UI_ItemSlot[] inventoryItemSlot;\n    private UI_ItemSlot[] stashItemSlot;\n    private UI_EquipmentSlot[] equipmentItemSlot;\n    private UI_StatSlot[] statSlots;\n    \n    private float flaskCooldown = 5f;\n    private float armorCooldown = 5f;\n    \n    \n    private void Awake()\n    {\n        if(instance == null)\n            instance = this;\n        else\n            Destroy(gameObject);\n    }\n\n    private void Start()\n    {\n        inventory = new List<InventoryItem>();\n        inventoryDictionary = new Dictionary<ItemData, InventoryItem>();\n        \n        stashItems = new List<InventoryItem>();\n        stashDictionary = new Dictionary<ItemData, InventoryItem>();\n        \n        equipment = new List<InventoryItem>();\n        equipmentDictionary = new Dictionary<ItemData_Equipment, InventoryItem>();\n        \n        inventoryItemSlot = inventorySlotParent.GetComponentsInChildren<UI_ItemSlot>();\n        stashItemSlot = stashSlotParent.GetComponentsInChildren<UI_ItemSlot>();\n        equipmentItemSlot = equipmentSlotParent.GetComponentsInChildren<UI_EquipmentSlot>();\n        statSlots = statSlotParent.GetComponentsInChildren<UI_StatSlot>();\n        \n        AddStartingItems();\n    }\n\n    private void AddStartingItems()\n    {\n        for (int i = 0; i < startingEquipment.Count; i++)\n        {   \n            if(startingEquipment[i] != null)\n                AddItem(startingEquipment[i]);\n        }\n    }\n\n    public void EquipItem(ItemData _item)\n    {\n        ItemData_Equipment newEquipment = _item as ItemData_Equipment;\n        InventoryItem newItem = new InventoryItem(newEquipment);\n\n        ItemData_Equipment oldEquipment = null;\n\n        foreach (KeyValuePair<ItemData_Equipment, InventoryItem> item in equipmentDictionary)\n        {\n            if (item.Key.equipmentType == newEquipment.equipmentType)\n                oldEquipment = item.Key;\n        }\n\n        if (oldEquipment != null)\n        {\n            UnEquipItem(oldEquipment);\n            AddItem(oldEquipment);\n        }\n\n\n        equipment.Add(newItem);\n        equipmentDictionary.Add(newEquipment, newItem);\n        newEquipment.AddModifiers();\n\n        RemoveItem(_item);\n\n        UpdateSlotUI();\n    }\n\n    \n\n    public void UnEquipItem(ItemData_Equipment itemToUnequip)\n    {\n        // If there is an item to unequip then remove it from the equipment list and dictionary\n        if(equipmentDictionary.TryGetValue(itemToUnequip, out InventoryItem value))\n        {   \n            equipment.Remove(value);\n            equipmentDictionary.Remove(itemToUnequip);\n            itemToUnequip.RemoveModifiers();\n        }\n    }\n\n    private void UpdateSlotUI()\n    {\n        // Update the UI for the equipment slots\n        for (int i = 0; i < equipmentItemSlot.Length; i++)\n        {\n            foreach (KeyValuePair<ItemData_Equipment, InventoryItem> item in equipmentDictionary)\n            {\n                if (item.Key.equipmentType == equipmentItemSlot[i].slotType)\n                    equipmentItemSlot[i].UpdateSlot(item.Value);\n            }\n        }\n        \n        // Update the UI for the inventory slots\n        for (int i = 0; i < inventoryItemSlot.Length; i++)\n        {\n            inventoryItemSlot[i].CleanUpSlot();\n        }\n        \n        // Update the UI for the stash slots\n        for (int i = 0; i < stashItemSlot.Length; i++)\n        {\n            stashItemSlot[i].CleanUpSlot();\n        }\n        \n        \n        // Update the UI for the inventory slots\n        for (int i = 0; i < inventory.Count; i++)\n        {\n            inventoryItemSlot[i].UpdateSlot(inventory[i]);\n        }\n        \n        \n        // Update the UI for the stash slots\n        for (int i = 0; i < stashItems.Count; i++)\n        {\n            stashItemSlot[i].UpdateSlot(stashItems[i]);\n        }\n\n        // update the UI for the stat slots\n        for (int i = 0; i < statSlots.Length; i++)\n        {\n            statSlots[i].UpdateStatValueUI();\n        }\n        \n    }\n    \n    public void AddItem(ItemData _item)\n    {\n        if(_item.itemType == ItemType.Equipment)\n        {\n            AddToInventory(_item);\n        }\n        else if(_item.itemType == ItemType.Material)\n        {\n            AddToStash(_item);\n        }\n        \n        UpdateSlotUI();\n    }\n\n    private void AddToStash(ItemData _item)\n    {\n        if(stashDictionary.TryGetValue(_item, out InventoryItem stashItem))\n        {\n            stashItem.AddStack();\n        }\n        else\n        {\n            InventoryItem newItem = new InventoryItem(_item);\n            stashItems.Add(newItem);\n            stashDictionary.Add(_item, newItem);\n        }\n    }\n\n    private void AddToInventory(ItemData item)\n    {\n        if(inventoryDictionary.TryGetValue(item, out InventoryItem inventoryItem))\n        {\n            inventoryItem.AddStack();\n        }\n        else\n        {\n            InventoryItem newItem = new InventoryItem(item);\n            inventory.Add(newItem);\n            inventoryDictionary.Add(item, newItem);\n        }\n    }\n\n    public void RemoveItem(ItemData item)\n    {\n        if(inventoryDictionary.TryGetValue(item, out InventoryItem inventoryItem))\n        {\n            if(inventoryItem.stackSize <= 1)\n            {\n                inventory.Remove(inventoryItem);\n                inventoryDictionary.Remove(item);\n            }\n            else\n            {\n                inventoryItem.RemoveStack();\n            }\n        }\n        \n        if(stashDictionary.TryGetValue(item, out InventoryItem stashItem))\n        {\n            if(stashItem.stackSize <= 1)\n            {\n                stashItems.Remove(stashItem);\n                stashDictionary.Remove(item);\n            }\n            else\n            {\n                stashItem.RemoveStack();\n            }\n        }\n        \n        UpdateSlotUI();\n    }\n\n    public bool CanCraft(ItemData_Equipment itemToCraft, List<InventoryItem> _requiredMaterials)\n    {   \n        List<InventoryItem> matialsToRemove = new List<InventoryItem>(); // List of materials to remove from the stash \n       for(int i = 0; i < _requiredMaterials.Count; i++) // Check if the player has the required materials to craft the item\n       {\n           // Check if the player has the required materials\n           if(stashDictionary.TryGetValue(_requiredMaterials[i].data, out InventoryItem stashItem))\n           { // If the player has the required materials then check if the player has enough of the materials\n              if(stashItem.stackSize < _requiredMaterials[i].stackSize)\n              {\n                  //Debug.Log(\"You do not have the required materials\");\n                  return false;\n              }\n              else\n              {\n                  //matialsToRemove.Add(stashItem);\n                  matialsToRemove.Add(stashItem);\n              }\n           }\n           else\n           {\n               Debug.Log(\"not enough materials\");\n               return false;\n           }\n       }\n        \n       // If the player has the required materials then remove the materials from the stash and add the crafted item to the inventory\n       for (int i = 0; i < matialsToRemove.Count; i++)\n       {\n           RemoveItem(matialsToRemove[i].data);\n       }\n       // Add the crafted item to the inventory\n       AddItem(itemToCraft);\n       Debug.Log(\"Crafting Successful\");\n       return true;\n       \n    }\n    \n    public List<InventoryItem>  GetEquipmentList() => equipment;\n    public List<InventoryItem> GetStashList() => stashItems;\n    \n    public ItemData_Equipment GetEquipmentType(EquipmentType _equipmentType)\n    {\n        ItemData_Equipment equipedItem = null;\n        foreach (KeyValuePair<ItemData_Equipment, InventoryItem> item in equipmentDictionary)\n        {\n            if(item.Key.equipmentType == _equipmentType)\n                equipedItem = item.Key;\n        }\n\n        return equipedItem;\n    }\n\n    public void UseFlask()\n    {\n        ItemData_Equipment currentFlask = GetEquipmentType(EquipmentType.Flask);\n        \n        if(currentFlask == null)\n        {\n           // Debug.Log(\"No Flask Equipped\");\n            return;\n        }\n        \n        bool canUseFlask = Time.time > lastFlaskUsed + flaskCooldown;\n\n        if (canUseFlask)\n        {\n            flaskCooldown = currentFlask.itemCooldown;\n            currentFlask.Effect(null);\n            lastFlaskUsed = Time.time;\n        }else\n        {\n            Debug.Log(\"Flask is on cooldown\");\n        }\n        \n    }\n\n    public bool CanUseArmor()\n    {\n        ItemData_Equipment currentArmor = GetEquipmentType(EquipmentType.Armor);\n        \n        if(Time.time > lastArmorUsed + armorCooldown)\n        {\n            armorCooldown = currentArmor.itemCooldown;  \n            lastArmorUsed = Time.time;\n            return true;\n        }\n        Debug.Log(\"Armor is on cooldown\");\n        return false;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Items and Inventory/Inventory.cs b/Assets/Scripts/Items and Inventory/Inventory.cs
--- a/Assets/Scripts/Items and Inventory/Inventory.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/Items and Inventory/Inventory.cs	(date 1716917720353)
@@ -1,329 +1,344 @@
 using System.Collections.Generic;
+using UI;
 using UnityEngine;
-using UnityEngine.Serialization;
 
-public class Inventory : MonoBehaviour
-{   
-    public static Inventory instance;
-    
-    public List<ItemData> startingEquipment;
-    
-    public List<InventoryItem> equipment;
-    public Dictionary<ItemData_Equipment, InventoryItem> equipmentDictionary;
+namespace Items_and_Inventory
+{
+    public class Inventory : MonoBehaviour
+    {
+        public static Inventory Instance;
+
+        public List<ItemData> startingEquipment;
+
+        public List<InventoryItem> equipment;
+        public Dictionary<ItemData_Equipment, InventoryItem> EquipmentDictionary;
 
-    public List<InventoryItem> inventory;
-    public Dictionary<ItemData, InventoryItem> inventoryDictionary;
-    
-    public List<InventoryItem> stashItems;
-    public Dictionary<ItemData, InventoryItem> stashDictionary;
-    
-    
-    [Header("Inventory UI")]
-    
-    [SerializeField] private Transform inventorySlotParent;
-    [SerializeField] private Transform stashSlotParent;
-    [SerializeField] private Transform equipmentSlotParent;
-    [SerializeField] private Transform statSlotParent;
-    
-    
-    [Header("Items cooldown")]
-    private float lastFlaskUsed;
-    private float lastArmorUsed;
-    
-    private UI_ItemSlot[] inventoryItemSlot;
-    private UI_ItemSlot[] stashItemSlot;
-    private UI_EquipmentSlot[] equipmentItemSlot;
-    private UI_StatSlot[] statSlots;
-    
-    private float flaskCooldown = 5f;
-    private float armorCooldown = 5f;
-    
-    
-    private void Awake()
-    {
-        if(instance == null)
-            instance = this;
-        else
-            Destroy(gameObject);
-    }
+        public List<InventoryItem> inventory;
+        public Dictionary<ItemData, InventoryItem> InventoryDictionary;
+
+        public List<InventoryItem> stashItems;
+        public Dictionary<ItemData, InventoryItem> StashDictionary;
+
+
+        [Header("Inventory UI")] [SerializeField]
+        private Transform inventorySlotParent;
+
+        [SerializeField] private Transform stashSlotParent;
+        [SerializeField] private Transform equipmentSlotParent;
+        [SerializeField] private Transform statSlotParent;
+
+
+        [Header("Items cooldown")] private float _lastFlaskUsed;
+        private float _lastArmorUsed;
+
+        private UIItemSlot[] _inventoryItemSlot;
+        private UIItemSlot[] _stashItemSlot;
+        private UIEquipmentSlot[] _equipmentItemSlot;
+        private UI_StatSlot[] _statSlots;
+
+        private float _flaskCooldown = 5f;
+        private float _armorCooldown = 5f;
+
+
+        private void Awake()
+        {
+            if (Instance == null)
+                Instance = this;
+            else
+                Destroy(gameObject);
+        }
 
-    private void Start()
-    {
-        inventory = new List<InventoryItem>();
-        inventoryDictionary = new Dictionary<ItemData, InventoryItem>();
-        
-        stashItems = new List<InventoryItem>();
-        stashDictionary = new Dictionary<ItemData, InventoryItem>();
-        
-        equipment = new List<InventoryItem>();
-        equipmentDictionary = new Dictionary<ItemData_Equipment, InventoryItem>();
-        
-        inventoryItemSlot = inventorySlotParent.GetComponentsInChildren<UI_ItemSlot>();
-        stashItemSlot = stashSlotParent.GetComponentsInChildren<UI_ItemSlot>();
-        equipmentItemSlot = equipmentSlotParent.GetComponentsInChildren<UI_EquipmentSlot>();
-        statSlots = statSlotParent.GetComponentsInChildren<UI_StatSlot>();
-        
-        AddStartingItems();
-    }
+        private void Start()
+        {
+            inventory = new List<InventoryItem>();
+            InventoryDictionary = new Dictionary<ItemData, InventoryItem>();
+
+            stashItems = new List<InventoryItem>();
+            StashDictionary = new Dictionary<ItemData, InventoryItem>();
+
+            equipment = new List<InventoryItem>();
+            EquipmentDictionary = new Dictionary<ItemData_Equipment, InventoryItem>();
+
+            _inventoryItemSlot = inventorySlotParent.GetComponentsInChildren<UIItemSlot>();
+            _stashItemSlot = stashSlotParent.GetComponentsInChildren<UIItemSlot>();
+            _equipmentItemSlot = equipmentSlotParent.GetComponentsInChildren<UIEquipmentSlot>();
+            _statSlots = statSlotParent.GetComponentsInChildren<UI_StatSlot>();
+
+            AddStartingItems();
+        }
 
-    private void AddStartingItems()
-    {
-        for (int i = 0; i < startingEquipment.Count; i++)
-        {   
-            if(startingEquipment[i] != null)
-                AddItem(startingEquipment[i]);
-        }
-    }
+        private void AddStartingItems()
+        {
+            for (int i = 0; i < startingEquipment.Count; i++)
+            {
+                if (startingEquipment[i] != null)
+                    AddItem(startingEquipment[i]);
+            }
+        }
 
-    public void EquipItem(ItemData _item)
-    {
-        ItemData_Equipment newEquipment = _item as ItemData_Equipment;
-        InventoryItem newItem = new InventoryItem(newEquipment);
+        public void EquipItem(ItemData item)
+        {   
+            ItemData_Equipment newEquipment = item as ItemData_Equipment;
+            InventoryItem newItem = new InventoryItem(newEquipment);
 
-        ItemData_Equipment oldEquipment = null;
+            ItemData_Equipment oldEquipment = null;
 
-        foreach (KeyValuePair<ItemData_Equipment, InventoryItem> item in equipmentDictionary)
-        {
-            if (item.Key.equipmentType == newEquipment.equipmentType)
-                oldEquipment = item.Key;
-        }
+            foreach (KeyValuePair<ItemData_Equipment, InventoryItem> _item in EquipmentDictionary)
+            {
+                if (_item.Key.equipmentType == newEquipment.equipmentType)
+                    oldEquipment = _item.Key;
+            }
 
-        if (oldEquipment != null)
-        {
-            UnEquipItem(oldEquipment);
-            AddItem(oldEquipment);
-        }
+            if (oldEquipment != null)
+            {   
+                AddItem(oldEquipment);
+                UnEquipItem(oldEquipment);
+            }
 
 
-        equipment.Add(newItem);
-        equipmentDictionary.Add(newEquipment, newItem);
-        newEquipment.AddModifiers();
+            equipment.Add(newItem);
+            EquipmentDictionary.Add(newEquipment, newItem);
+            newEquipment.AddModifiers();
 
-        RemoveItem(_item);
+            RemoveItem(item);
 
-        UpdateSlotUI();
-    }
+            UpdateSlotUI();
+        }
 
-    
+
 
-    public void UnEquipItem(ItemData_Equipment itemToUnequip)
-    {
-        // If there is an item to unequip then remove it from the equipment list and dictionary
-        if(equipmentDictionary.TryGetValue(itemToUnequip, out InventoryItem value))
-        {   
-            equipment.Remove(value);
-            equipmentDictionary.Remove(itemToUnequip);
-            itemToUnequip.RemoveModifiers();
-        }
-    }
+        public void UnEquipItem(ItemData_Equipment itemToUnequip)
+        {
+            // If there is an item to unequip then remove it from the equipment list and dictionary
+            if (EquipmentDictionary.TryGetValue(itemToUnequip, out InventoryItem value))
+            {
+                equipment.Remove(value);
+                EquipmentDictionary.Remove(itemToUnequip);
+                itemToUnequip.RemoveModifiers();
+            }
+        }
 
-    private void UpdateSlotUI()
-    {
-        // Update the UI for the equipment slots
-        for (int i = 0; i < equipmentItemSlot.Length; i++)
-        {
-            foreach (KeyValuePair<ItemData_Equipment, InventoryItem> item in equipmentDictionary)
-            {
-                if (item.Key.equipmentType == equipmentItemSlot[i].slotType)
-                    equipmentItemSlot[i].UpdateSlot(item.Value);
-            }
-        }
-        
-        // Update the UI for the inventory slots
-        for (int i = 0; i < inventoryItemSlot.Length; i++)
-        {
-            inventoryItemSlot[i].CleanUpSlot();
-        }
-        
-        // Update the UI for the stash slots
-        for (int i = 0; i < stashItemSlot.Length; i++)
-        {
-            stashItemSlot[i].CleanUpSlot();
-        }
-        
-        
-        // Update the UI for the inventory slots
-        for (int i = 0; i < inventory.Count; i++)
-        {
-            inventoryItemSlot[i].UpdateSlot(inventory[i]);
-        }
-        
-        
-        // Update the UI for the stash slots
-        for (int i = 0; i < stashItems.Count; i++)
-        {
-            stashItemSlot[i].UpdateSlot(stashItems[i]);
-        }
+        private void UpdateSlotUI()
+        {
+            // Update the UI for the equipment slots
+            for (int i = 0; i < _equipmentItemSlot.Length; i++)
+            {
+                foreach (KeyValuePair<ItemData_Equipment, InventoryItem> item in EquipmentDictionary)
+                {
+                    if (item.Key.equipmentType == _equipmentItemSlot[i].slotType)
+                        _equipmentItemSlot[i].UpdateSlot(item.Value);
+                }
+            }
+
+            // Update the UI for the inventory slots
+            for (int i = 0; i < _inventoryItemSlot.Length; i++)
+            {
+                _inventoryItemSlot[i].CleanUpSlot();
+            }
+
+            // Update the UI for the stash slots
+            for (int i = 0; i < _stashItemSlot.Length; i++)
+            {
+                _stashItemSlot[i].CleanUpSlot();
+            }
+
+
+            // Update the UI for the inventory slots
+            for (int i = 0; i < inventory.Count; i++)
+            {
+                _inventoryItemSlot[i].UpdateSlot(inventory[i]);
+            }
+
+
+            // Update the UI for the stash slots
+            for (int i = 0; i < stashItems.Count; i++)
+            {
+                _stashItemSlot[i].UpdateSlot(stashItems[i]);
+            }
 
-        // update the UI for the stat slots
-        for (int i = 0; i < statSlots.Length; i++)
-        {
-            statSlots[i].UpdateStatValueUI();
-        }
-        
-    }
-    
-    public void AddItem(ItemData _item)
-    {
-        if(_item.itemType == ItemType.Equipment)
+            // update the UI for the stat slots
+            for (int i = 0; i < _statSlots.Length; i++)
+            {
+                _statSlots[i].UpdateStatValueUI();
+            }
+
+        }
+
+        public void AddItem(ItemData _item)
         {
-            AddToInventory(_item);
-        }
-        else if(_item.itemType == ItemType.Material)
-        {
-            AddToStash(_item);
-        }
-        
-        UpdateSlotUI();
-    }
+            if (_item.itemType == ItemType.Equipment && CanAddItem())
+                AddToInventory(_item);
+            else if (_item.itemType == ItemType.Material)
+                AddToStash(_item);
+            UpdateSlotUI();
+        }
 
-    private void AddToStash(ItemData _item)
-    {
-        if(stashDictionary.TryGetValue(_item, out InventoryItem stashItem))
-        {
-            stashItem.AddStack();
-        }
-        else
-        {
-            InventoryItem newItem = new InventoryItem(_item);
-            stashItems.Add(newItem);
-            stashDictionary.Add(_item, newItem);
-        }
-    }
+        private void AddToStash(ItemData _item)
+        {
+            if (StashDictionary.TryGetValue(_item, out InventoryItem stashItem))
+            {
+                stashItem.AddStack();
+            }
+            else
+            {
+                InventoryItem newItem = new InventoryItem(_item);
+                stashItems.Add(newItem);
+                StashDictionary.Add(_item, newItem);
+            }
+        }
 
-    private void AddToInventory(ItemData item)
-    {
-        if(inventoryDictionary.TryGetValue(item, out InventoryItem inventoryItem))
-        {
-            inventoryItem.AddStack();
-        }
-        else
-        {
-            InventoryItem newItem = new InventoryItem(item);
-            inventory.Add(newItem);
-            inventoryDictionary.Add(item, newItem);
-        }
-    }
+        private void AddToInventory(ItemData item)
+        {
+            if (InventoryDictionary.TryGetValue(item, out InventoryItem inventoryItem))
+            {
+                inventoryItem.AddStack();
+            }
+            else
+            {
+                InventoryItem newItem = new InventoryItem(item);
+                inventory.Add(newItem);
+                InventoryDictionary.Add(item, newItem);
+            }
+        }
 
-    public void RemoveItem(ItemData item)
-    {
-        if(inventoryDictionary.TryGetValue(item, out InventoryItem inventoryItem))
-        {
-            if(inventoryItem.stackSize <= 1)
-            {
-                inventory.Remove(inventoryItem);
-                inventoryDictionary.Remove(item);
-            }
-            else
-            {
-                inventoryItem.RemoveStack();
-            }
-        }
-        
-        if(stashDictionary.TryGetValue(item, out InventoryItem stashItem))
-        {
-            if(stashItem.stackSize <= 1)
-            {
-                stashItems.Remove(stashItem);
-                stashDictionary.Remove(item);
-            }
-            else
-            {
-                stashItem.RemoveStack();
-            }
-        }
-        
-        UpdateSlotUI();
-    }
+        public void RemoveItem(ItemData item)
+        {
+            if (InventoryDictionary.TryGetValue(item, out InventoryItem inventoryItem))
+            {
+                if (inventoryItem.stackSize <= 1)
+                {
+                    inventory.Remove(inventoryItem);
+                    InventoryDictionary.Remove(item);
+                }
+                else
+                {
+                    inventoryItem.RemoveStack();
+                }
+            }
+
+            if (StashDictionary.TryGetValue(item, out InventoryItem stashItem))
+            {
+                if (stashItem.stackSize <= 1)
+                {
+                    stashItems.Remove(stashItem);
+                    StashDictionary.Remove(item);
+                }
+                else
+                {
+                    stashItem.RemoveStack();
+                }
+            }
+
+            UpdateSlotUI();
+        }
 
-    public bool CanCraft(ItemData_Equipment itemToCraft, List<InventoryItem> _requiredMaterials)
-    {   
-        List<InventoryItem> matialsToRemove = new List<InventoryItem>(); // List of materials to remove from the stash 
-       for(int i = 0; i < _requiredMaterials.Count; i++) // Check if the player has the required materials to craft the item
-       {
-           // Check if the player has the required materials
-           if(stashDictionary.TryGetValue(_requiredMaterials[i].data, out InventoryItem stashItem))
-           { // If the player has the required materials then check if the player has enough of the materials
-              if(stashItem.stackSize < _requiredMaterials[i].stackSize)
-              {
-                  //Debug.Log("You do not have the required materials");
-                  return false;
-              }
-              else
-              {
-                  //matialsToRemove.Add(stashItem);
-                  matialsToRemove.Add(stashItem);
-              }
-           }
-           else
-           {
-               Debug.Log("not enough materials");
-               return false;
-           }
-       }
-        
-       // If the player has the required materials then remove the materials from the stash and add the crafted item to the inventory
-       for (int i = 0; i < matialsToRemove.Count; i++)
-       {
-           RemoveItem(matialsToRemove[i].data);
-       }
-       // Add the crafted item to the inventory
-       AddItem(itemToCraft);
-       Debug.Log("Crafting Successful");
-       return true;
-       
-    }
-    
-    public List<InventoryItem>  GetEquipmentList() => equipment;
-    public List<InventoryItem> GetStashList() => stashItems;
-    
-    public ItemData_Equipment GetEquipmentType(EquipmentType _equipmentType)
-    {
-        ItemData_Equipment equipedItem = null;
-        foreach (KeyValuePair<ItemData_Equipment, InventoryItem> item in equipmentDictionary)
-        {
-            if(item.Key.equipmentType == _equipmentType)
-                equipedItem = item.Key;
-        }
+        public bool CanAddItem()
+        {
+            if (inventory.Count >= _inventoryItemSlot.Length)
+            {
+                Debug.Log("Inventory is full");
+                return false;
+            }
+
+            return true;
+        }
+
+        public bool CanCraft(ItemData_Equipment itemToCraft, List<InventoryItem> _requiredMaterials)
+        {
+            List<InventoryItem>
+                matialsToRemove = new List<InventoryItem>(); // List of materials to remove from the stash 
+            for (int i = 0;
+                 i < _requiredMaterials.Count;
+                 i++) // Check if the player has the required materials to craft the item
+            {
+                // Check if the player has the required materials
+                if (StashDictionary.TryGetValue(_requiredMaterials[i].data, out InventoryItem stashItem))
+                {
+                    // If the player has the required materials then check if the player has enough of the materials
+                    if (stashItem.stackSize < _requiredMaterials[i].stackSize)
+                    {
+                        //Debug.Log("You do not have the required materials");
+                        return false;
+                    }
+                    else
+                    {
+                        //matialsToRemove.Add(stashItem);
+                        matialsToRemove.Add(stashItem);
+                    }
+                }
+                else
+                {
+                    Debug.Log("not enough materials");
+                    return false;
+                }
+            }
+
+            // If the player has the required materials then remove the materials from the stash and add the crafted item to the inventory
+            for (int i = 0; i < matialsToRemove.Count; i++)
+            {
+                RemoveItem(matialsToRemove[i].data);
+            }
+
+            // Add the crafted item to the inventory
+            AddItem(itemToCraft);
+            Debug.Log("Crafting Successful");
+            return true;
+
+        }
+
+        public List<InventoryItem> GetEquipmentList() => equipment;
+        public List<InventoryItem> GetStashList() => stashItems;
+
+        public ItemData_Equipment GetEquipmentType(EquipmentType equipmentType)
+        {
+            ItemData_Equipment equipedItem = null;
+            foreach (KeyValuePair<ItemData_Equipment, InventoryItem> item in EquipmentDictionary)
+            {
+                if (item.Key.equipmentType == equipmentType)
+                    equipedItem = item.Key;
+            }
 
-        return equipedItem;
-    }
+            return equipedItem;
+        }
 
-    public void UseFlask()
-    {
-        ItemData_Equipment currentFlask = GetEquipmentType(EquipmentType.Flask);
-        
-        if(currentFlask == null)
-        {
-           // Debug.Log("No Flask Equipped");
-            return;
-        }
-        
-        bool canUseFlask = Time.time > lastFlaskUsed + flaskCooldown;
+        public void UseFlask()
+        {
+            ItemData_Equipment currentFlask = GetEquipmentType(EquipmentType.Flask);
+
+            if (currentFlask == null)
+            {
+                // Debug.Log("No Flask Equipped");
+                return;
+            }
+
+            bool canUseFlask = Time.time > _lastFlaskUsed + _flaskCooldown;
 
-        if (canUseFlask)
-        {
-            flaskCooldown = currentFlask.itemCooldown;
-            currentFlask.Effect(null);
-            lastFlaskUsed = Time.time;
-        }else
-        {
-            Debug.Log("Flask is on cooldown");
-        }
-        
-    }
+            if (canUseFlask)
+            {
+                _flaskCooldown = currentFlask.itemCooldown;
+                currentFlask.Effect(null);
+                _lastFlaskUsed = Time.time;
+            }
+            else
+            {
+                Debug.Log("Flask is on cooldown");
+            }
+
+        }
 
-    public bool CanUseArmor()
-    {
-        ItemData_Equipment currentArmor = GetEquipmentType(EquipmentType.Armor);
-        
-        if(Time.time > lastArmorUsed + armorCooldown)
-        {
-            armorCooldown = currentArmor.itemCooldown;  
-            lastArmorUsed = Time.time;
-            return true;
-        }
-        Debug.Log("Armor is on cooldown");
-        return false;
-    }
-}
+        public bool CanUseArmor()
+        {
+            ItemData_Equipment currentArmor = GetEquipmentType(EquipmentType.Armor);
+
+            if (Time.time > _lastArmorUsed + _armorCooldown)
+            {
+                _armorCooldown = currentArmor.itemCooldown;
+                _lastArmorUsed = Time.time;
+                return true;
+            }
+
+            Debug.Log("Armor is on cooldown");
+            return false;
+        }
+    }
+}
\ No newline at end of file
Index: Assets/Scripts/Items and Inventory/itemObjTrigger.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System;\nusing UnityEngine;\n\npublic class itemObjTrigger : MonoBehaviour\n{\n    private itemObj myItemObj => GetComponentInParent<itemObj>();\n    \n    private void OnTriggerEnter2D(Collider2D other)\n    {\n        if (other.GetComponent<Player>() != null)\n        {\n            if(other.GetComponent<CharacterStats>().isDead)\n                return;\n                \n            \n            Debug.Log(\"Player picked up item!\");\n            myItemObj.PickupItem();\n            \n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Items and Inventory/itemObjTrigger.cs b/Assets/Scripts/Items and Inventory/itemObjTrigger.cs
--- a/Assets/Scripts/Items and Inventory/itemObjTrigger.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/Items and Inventory/itemObjTrigger.cs	(date 1716917720357)
@@ -1,21 +1,25 @@
-using System;
+
 using UnityEngine;
 
-public class itemObjTrigger : MonoBehaviour
+namespace Items_and_Inventory
 {
-    private itemObj myItemObj => GetComponentInParent<itemObj>();
-    
-    private void OnTriggerEnter2D(Collider2D other)
-    {
-        if (other.GetComponent<Player>() != null)
-        {
-            if(other.GetComponent<CharacterStats>().isDead)
-                return;
-                
-            
-            Debug.Log("Player picked up item!");
-            myItemObj.PickupItem();
-            
-        }
-    }
-}
+
+    public class ItemObjTrigger : MonoBehaviour
+    {
+        private ItemObj MyItemObj => GetComponentInParent<ItemObj>();
+
+        private void OnTriggerEnter2D(Collider2D other)
+        {
+            if (other.GetComponent<Player>() != null)
+            {
+                if (other.GetComponent<CharacterStats>().isDead)
+                    return;
+
+
+                Debug.Log("Player picked up item!");
+                MyItemObj.PickupItem();
+
+            }
+        }
+    }
+}
\ No newline at end of file
Index: Assets/Scripts/Status/EnemyStats.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using UnityEngine;\n\npublic class EnemyStats : CharacterStats\n{\n    private Enemy enemy;\n    private ItemDrop myDropSystem;\n    [Header(\"Level Details\")]\n    [SerializeField] private int level = 1;\n  //  [SerializeField] private int experience = 0;\n    \n    [Range(0f, 1f)]\n    [SerializeField] private float percantageModifier = 0.4f;\n    \n    protected override void Start()\n    {\n        ApplyLevelModify();\n\n        base.Start();\n        enemy = GetComponent<Enemy>();\n        \n        myDropSystem = GetComponent<ItemDrop>();\n        \n    }\n\n    private void ApplyLevelModify()\n    {   \n        Modify(strength);\n        Modify(agility);\n        Modify(intelligence);\n        Modify(vitality);\n        \n        Modify(attackPower);\n        Modify(critChance);\n        Modify(critPower);\n        \n        Modify(armor);\n        Modify(maxHealth);\n        Modify(evasion);\n        Modify(magicResistance);\n        \n        Modify(fireDamage);\n        Modify(iceDamage);\n        Modify(lightningDamage);\n    }\n\n    public override void TakeDamage(int damage)\n    {\n        base.TakeDamage(damage);\n   \n    }\n    \n    \n    private void Modify(Stat _stat)\n    {\n        for (int i =  1; i < level; i++)\n        {\n            float modifier = _stat.GetValue() * percantageModifier;\n            \n            _stat.AddModifier(Mathf.RoundToInt(modifier));\n        }\n    }\n    \n\n    protected override void Die()\n    {\n        base.Die();\n        enemy.Die();\n        myDropSystem.GenerateDrop();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Status/EnemyStats.cs b/Assets/Scripts/Status/EnemyStats.cs
--- a/Assets/Scripts/Status/EnemyStats.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/Status/EnemyStats.cs	(date 1716917720360)
@@ -1,3 +1,4 @@
+using Items_and_Inventory;
 using UnityEngine;
 
 public class EnemyStats : CharacterStats
Index: Assets/Scripts/Items and Inventory/Effect/FreezeEnemiesEffect.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using UnityEngine;\n\n[CreateAssetMenu(fileName = \"Freeze enemies effect\", menuName = \"Inventory System/Items/Effects/FreezeEnemiesEffect\")]\npublic class FreezeEnemiesEffect : ItemEffect\n{\n    [SerializeField] private float duration;\n\n\n    public override void ExecuteEffect(Transform _transform)\n    {\n        PlayerStats playerStats = PlayerManager.instance.player.GetComponent<PlayerStats>();\n        \n        if(playerStats.currentHealth > playerStats.GetMaxHeathValue() * .1f)\n            return;\n        \n        if(!Inventory.instance.CanUseArmor())\n            return;\n        \n        Collider2D[] enemies = Physics2D.OverlapCircleAll(_transform.position, 2);\n\n        foreach (var hit in enemies)\n        {\n            hit.GetComponent<Enemy>()?.FreezeTimeFor(duration);\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Items and Inventory/Effect/FreezeEnemiesEffect.cs b/Assets/Scripts/Items and Inventory/Effect/FreezeEnemiesEffect.cs
--- a/Assets/Scripts/Items and Inventory/Effect/FreezeEnemiesEffect.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/Items and Inventory/Effect/FreezeEnemiesEffect.cs	(date 1716917720353)
@@ -1,3 +1,4 @@
+using Items_and_Inventory;
 using UnityEngine;
 
 [CreateAssetMenu(fileName = "Freeze enemies effect", menuName = "Inventory System/Items/Effects/FreezeEnemiesEffect")]
@@ -13,7 +14,7 @@
         if(playerStats.currentHealth > playerStats.GetMaxHeathValue() * .1f)
             return;
         
-        if(!Inventory.instance.CanUseArmor())
+        if(!Inventory.Instance.CanUseArmor())
             return;
         
         Collider2D[] enemies = Physics2D.OverlapCircleAll(_transform.position, 2);
Index: Assets/Scripts/Status/PlayerStats.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using UnityEngine;\n\npublic class PlayerStats : CharacterStats\n{\n    private Player player;\n    protected override void Start()\n    {\n        base.Start();\n        player = GetComponent<Player>();\n    }\n\n    public override void TakeDamage(int damage)\n    {\n        base.TakeDamage(damage);\n        \n    }\n\n    protected override void Die()\n    {\n        base.Die();\n        player.Die();\n        GetComponent<PlayerItemDrop>()?.GenerateDrop();\n    }\n\n    protected override void DecreasHealthBy(int damage)\n    {\n        base.DecreasHealthBy(damage);\n\n        if (Inventory.instance.GetEquipmentType(EquipmentType.Armor) == null)\n            return;\n        \n        \n        ItemData_Equipment curArmor = Inventory.instance.GetEquipmentType(EquipmentType.Armor);\n        \n        if(curArmor != null)\n            curArmor.Effect(player.transform);\n        \n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Status/PlayerStats.cs b/Assets/Scripts/Status/PlayerStats.cs
--- a/Assets/Scripts/Status/PlayerStats.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/Status/PlayerStats.cs	(date 1716917720360)
@@ -1,3 +1,4 @@
+using Items_and_Inventory;
 using UnityEngine;
 
 public class PlayerStats : CharacterStats
@@ -26,11 +27,11 @@
     {
         base.DecreasHealthBy(damage);
 
-        if (Inventory.instance.GetEquipmentType(EquipmentType.Armor) == null)
+        if (Inventory.Instance.GetEquipmentType(EquipmentType.Armor) == null)
             return;
         
         
-        ItemData_Equipment curArmor = Inventory.instance.GetEquipmentType(EquipmentType.Armor);
+        ItemData_Equipment curArmor = Inventory.Instance.GetEquipmentType(EquipmentType.Armor);
         
         if(curArmor != null)
             curArmor.Effect(player.transform);
Index: Assets/Scripts/Items and Inventory/itemObj.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System;\nusing UnityEngine;\n\npublic class itemObj : MonoBehaviour\n{\n    [SerializeField] private Rigidbody2D rb;\n    [SerializeField] private ItemData itemData;\n    private void SetupVisual()\n    {\n        if(itemData == null)\n            return;\n        \n        GetComponent<SpriteRenderer>().sprite = itemData.itemIcon;\n        gameObject.name = \"Item object - \" + itemData.itemName;\n    }\n    \n    \n    public void SetupItemObj(ItemData _itemData, Vector2 _velocity)\n    {\n        itemData = _itemData;\n        rb.velocity = _velocity;\n        \n        SetupVisual();\n    }\n  \n\n    public void PickupItem()\n    {\n        Inventory.instance.AddItem(itemData);\n        Destroy(gameObject);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Items and Inventory/itemObj.cs b/Assets/Scripts/Items and Inventory/ItemObj.cs
rename from Assets/Scripts/Items and Inventory/itemObj.cs
rename to Assets/Scripts/Items and Inventory/ItemObj.cs
--- a/Assets/Scripts/Items and Inventory/itemObj.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/Items and Inventory/ItemObj.cs	(date 1716917720356)
@@ -1,32 +1,42 @@
-using System;
 using UnityEngine;
 
-public class itemObj : MonoBehaviour
+namespace Items_and_Inventory
 {
-    [SerializeField] private Rigidbody2D rb;
-    [SerializeField] private ItemData itemData;
-    private void SetupVisual()
-    {
-        if(itemData == null)
-            return;
-        
-        GetComponent<SpriteRenderer>().sprite = itemData.itemIcon;
-        gameObject.name = "Item object - " + itemData.itemName;
-    }
-    
-    
-    public void SetupItemObj(ItemData _itemData, Vector2 _velocity)
-    {
-        itemData = _itemData;
-        rb.velocity = _velocity;
-        
-        SetupVisual();
-    }
-  
+    public class ItemObj : MonoBehaviour
+    {
+        [SerializeField] private Rigidbody2D rb;
+        [SerializeField] private ItemData itemData;
+
+        private void SetupVisual()
+        {
+            if (itemData == null)
+                return;
+
+            GetComponent<SpriteRenderer>().sprite = itemData.itemIcon;
+            gameObject.name = "Item object - " + itemData.itemName;
+        }
+
+
+        public void SetupItemObj(ItemData itemData, Vector2 velocity)
+        {
+            this.itemData = itemData;
+            rb.velocity = velocity;
+
+            SetupVisual();
+        }
+
 
-    public void PickupItem()
-    {
-        Inventory.instance.AddItem(itemData);
-        Destroy(gameObject);
-    }
-}
+        public void PickupItem()
+        {
+            if (!Inventory.Instance.CanAddItem() && itemData.itemType == ItemType.Equipment)
+            {
+                rb.velocity = new Vector2(0, 7);
+                return;
+
+            }
+
+            Inventory.Instance.AddItem(itemData);
+            Destroy(gameObject);
+        }
+    }
+}
\ No newline at end of file
Index: Assets/Scripts/Status/CharacterStats.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Serialization;\n\npublic enum StatType\n{\n    strength,\n    agility,\n    intelegence,\n    vitality,\n    attackPower,\n    critChance,\n    critPower,\n    armor,\n    maxHealth,\n    evasion,\n    fireDamage,\n    iceDamage,\n    lightningDamage,\n    magicResistance,\n}\n\n\npublic class CharacterStats : MonoBehaviour\n{\n    private EntityFX fx;\n    \n    [FormerlySerializedAs(\"strenght\")] [Header(\"Major stats\")]\n    public Stat strength; // 1 point increase attackPower by 1 and crit.power by 1%\n    public Stat agility; // 1 point increase evasion by 1% and crit.chance by 1%\n    [FormerlySerializedAs(\"intelegence\")] public Stat intelligence; // 1 point increase magic attackPower by 1 and magic resistance by 3\n    public Stat vitality;// 1 point increase health by 3 or 5 points\n    \n    [FormerlySerializedAs(\"damage\")] [Header(\"Offensive stats\")]\n    public Stat attackPower;\n    public Stat critChance;\n    public Stat critPower;          // default 150% of attackPower\n    \n    [Header(\"Defensive stats\")]\n    public Stat maxHealth;\n    public Stat armor;\n    public Stat evasion;\n    public Stat magicResistance;\n    \n    [Header(\"Magic stats\")]\n    public Stat fireDamage;\n    public Stat iceDamage;\n    public Stat lightningDamage;\n    \n    public bool isIgnited; // does attackPower over time\n    public bool isChiiled; // reduce movement speed by 20%\n    public bool isShocked; // increase attackPower taken by 20%\n\n    [SerializeField] private float ailmentDuration = 2;\n    private float igniteTimer;\n    private float chillTimer;\n    private float shockTimer;\n    \n    \n    \n    private float igniteDamageCooldown =.3f;\n    private float igniteDamageTimer;\n    private int igniteDamage ;\n    [SerializeField] private GameObject thunderStrikePrefab;\n    private int shockDamage ;\n    \n    \n    \n    //ublic Stat evasion;\n    public int currentHealth;\n    \n    public System.Action onHeathChanged;\n    public bool isDead {get; private set;}\n    \n    \n    // Start is called once before the first execution of Update after the MonoBehaviour is created\n    protected virtual void Start()\n    {   \n        critPower.SetBaseValue(150);\n        currentHealth = GetMaxHeathValue();\n        \n        fx = GetComponent<EntityFX>();\n\n    }\n    \n    protected virtual void Update()\n    {\n        igniteTimer -= Time.deltaTime;\n        chillTimer -= Time.deltaTime;\n        shockTimer -= Time.deltaTime;\n        \n        igniteDamageTimer -= Time.deltaTime;\n        \n        \n        if(igniteTimer < 0)\n            isIgnited = false;\n        \n        if(chillTimer < 0)\n            isChiiled = false;\n        \n        if(shockTimer < 0)\n            isShocked = false;\n        \n        if(isIgnited)\n            ApplyIgniteDamage();\n        \n    }\n\n\n    public virtual void IncreaStatBy(int _modifier, float _duration, Stat _statModify)\n    { \n        StartCoroutine(StatModCoroutine(_modifier, _duration, _statModify));\n        \n    }\n\n    private IEnumerator StatModCoroutine(int _modifier, float _duration, Stat _statModify)\n    {\n        _statModify.AddModifier(_modifier);\n        yield return new WaitForSeconds(_duration);\n        _statModify.RemoveModifier(_modifier);\n    }\n\n    public virtual void DoDamge(CharacterStats target)\n   {\n       if (TargetCanAvoidAttack(target)) \n           return;\n       \n       int totalDamage = attackPower.GetValue() + strength.GetValue();\n\n       if (CanCrit())\n       {\n           totalDamage = CalculateCritDamage(totalDamage);\n          // Debug.Log(\"Crit attackPower: \" + totalDamage);\n       }\n       \n       totalDamage = CheckTargetArmor(target, totalDamage);\n\n       target.TakeDamage(totalDamage);\n       \n       // if inventory current weapon is fire\n       \n        DoMagicDamage(target); // remove this line if u dont want to apply magic hit on primary attack\n       //target.TakeDamage(attackPower.GetValue());\n   }\n\n   public virtual void DoMagicDamage(CharacterStats target)\n   {\n       int _fireDamage = fireDamage.GetValue();\n       int _iceDamage = iceDamage.GetValue();\n       int _lightningDamage = lightningDamage.GetValue();\n       \n       int totalMagicDamage = _fireDamage + _iceDamage + _lightningDamage + intelligence.GetValue();\n       \n       totalMagicDamage = CheckTargetResitane(target, totalMagicDamage);\n\n       target.TakeDamage(totalMagicDamage);\n       \n       if(Mathf.Max(_fireDamage, _iceDamage, _lightningDamage) <= 0)\n           return;\n       \n       \n       AttemptyToApplyAilements(target, _fireDamage, _iceDamage, _lightningDamage);\n   }\n\n   #region Magiccal attackPower and ailements\n   private void ApplyIgniteDamage()\n   {\n       if(igniteDamageTimer < 0)\n       {\n           igniteDamageTimer = igniteDamageCooldown;\n          // Debug.Log(\"Burn: \" + igniteDamage);\n            \n           DecreasHealthBy(igniteDamage);\n           if(currentHealth <= 0 &&!isDead)\n               Die();\n       }\n   }\n   private static void AttemptyToApplyAilements(CharacterStats target, int _fireDamage, int _iceDamage,\n       int _lightningDamage)\n   {\n       bool canIgnite = _fireDamage > _iceDamage && _fireDamage > _lightningDamage;\n       bool canChill = _iceDamage > _fireDamage && _iceDamage > _lightningDamage;\n       bool canShock = _lightningDamage > _fireDamage && _lightningDamage > _iceDamage;\n       \n\n       while (!canIgnite && !canChill && !canShock)\n       {\n           if(Random.value < 0.3f && _fireDamage > 0)\n           {\n               canIgnite = true;\n               target.ApplyAilment(canIgnite, canChill, canShock);\n               Debug.Log(\"Ignited\"); \n               return;\n           }\n           if(Random.value < 0.5f && _iceDamage > 0)\n           {\n               canChill = true;\n               target.ApplyAilment(canIgnite, canChill, canShock);\n               Debug.Log(\"Chilled\");\n               return;\n           }\n           if(Random.value < 0.5f && _lightningDamage > 0)\n           {\n               canShock = true;\n               target.ApplyAilment(canIgnite, canChill, canShock); \n               Debug.Log(\"Shocked\");\n               return;\n           }\n           \n           \n       }\n       \n       if(canIgnite)\n           target.SetupIgniteDamage(Mathf.RoundToInt(_fireDamage * 0.2f));\n       \n       if(canShock)\n           target.SetupShockDamage(Mathf.RoundToInt(_lightningDamage * 0.1f));\n       \n       \n       target.ApplyAilment(canIgnite, canChill, canShock);\n   }\n   \n   public void ApplyAilment(bool _isIgnited, bool _isChilled, bool _isShocked)\n   {\n       bool canApplyIgnite = !isIgnited && !isChiiled && !isShocked;\n       bool canApplyChill = !isIgnited && !isChiiled && !isShocked;\n       bool canApplyShock = !isIgnited && !isChiiled;\n       \n\n       if (_isIgnited && canApplyIgnite)\n       {\n           isIgnited = _isIgnited;\n           igniteTimer = ailmentDuration;\n           \n           fx.IgniteFxFor(ailmentDuration);\n       }\n       \n       if (_isChilled && canApplyChill) {\n           \n             \n             chillTimer = ailmentDuration;\n             isChiiled = _isChilled; \n             \n             float slowPercentage = 0.2f;\n             GetComponent<Entity>().SlowEntityBy(slowPercentage, ailmentDuration);\n             fx.ChillFxFor(ailmentDuration);\n       }\n\n       if (_isShocked && canApplyShock)\n       {\n           if (!isShocked)\n           {\n               ApplyShock(_isShocked);\n               //Debug.Log(\"Shocked\");\n           }\n           else\n           {\n               if(GetComponent<Player>() != null)\n                   return;\n               //Debug.Log(\"Thunder strike\");\n               HitNearestTargetWithShockStrike();\n           }\n           \n       }\n       \n   }\n\n   public void ApplyShock(bool _isShocked)\n   {\n       if(isShocked)\n              return;\n       shockTimer = ailmentDuration;\n       isShocked = _isShocked;\n\n       fx.ShockFxFor(ailmentDuration);\n   }\n\n   private void HitNearestTargetWithShockStrike()\n   {\n       Collider2D[] colliders = Physics2D.OverlapCircleAll(transform.position, 25);\n       float closestDistance = Mathf.Infinity;\n       Transform closestEnemy = null;\n               \n       foreach (var hit in colliders)\n       {\n           if (hit.GetComponent<Enemy>() != null && Vector2.Distance(transform.position, hit.transform.position) > 1)\n           {\n               float distance = Vector2.Distance(transform.position, hit.transform.position);\n                        \n               if(distance < closestDistance)\n               {\n                   closestDistance = distance;\n                   closestEnemy = hit.transform;\n               }\n           }\n                    \n           if(closestEnemy == null) // if there is no enemy in the range of 25 units  \n               closestEnemy = transform;\n       }\n               \n       if (closestEnemy != null)\n       {   \n           //Debug.Log(\"Thunder strike\");\n                    \n           GameObject thunderStrike = Instantiate(thunderStrikePrefab, transform.position, Quaternion.identity);\n           thunderStrike.GetComponent<ShockStrikeController>().Setup(shockDamage, closestEnemy.GetComponent<CharacterStats>());\n       }\n   }\n\n   public void SetupIgniteDamage(int _damage) => igniteDamage = _damage;\n   public void SetupShockDamage(int _damage) => shockDamage = _damage;\n\n    #endregion\n    \n   public virtual void TakeDamage(int damage)\n    {\n        DecreasHealthBy(damage);\n        \n        //currentHealth -= attackPower;\n        GetComponent<Entity>().DamageImpact();\n        fx.StartCoroutine(\"FlashFX\");\n\n        if (currentHealth <= 0 && !isDead)\n        {\n            Die();\n        }\n        \n    }\n\n    public virtual void IncreaseHealthBy(int healAmount)\n    {\n        currentHealth += healAmount;\n        if(currentHealth > GetMaxHeathValue())\n            currentHealth = GetMaxHeathValue();\n        \n        if(onHeathChanged != null)\n            onHeathChanged();\n    }\n   \n    protected virtual void DecreasHealthBy(int damage)\n    {\n        currentHealth -= damage;\n        if(onHeathChanged != null)\n            onHeathChanged();\n    }\n   \n    protected virtual void Die()\n    {\n        isDead = true;\n        //Destroy(gameObject);\n    }\n\n    #region Stat calculation\n    private int CheckTargetArmor(CharacterStats target, int totalDamage)\n    {\n        if(target.isChiiled)\n            totalDamage -= Mathf.RoundToInt(target.armor.GetValue() * 0.8f);\n        else\n            totalDamage -= target.armor.GetValue() ;\n        \n        totalDamage -= target.armor.GetValue() ;\n        totalDamage = Mathf.Clamp(totalDamage, 0, int.MaxValue);\n        return totalDamage;\n    }\n   private bool TargetCanAvoidAttack(CharacterStats target)\n   {\n       int totalEvasion = target.evasion.GetValue() + target.agility.GetValue();\n       \n       if(isShocked)\n           totalEvasion += 20;\n       \n       if(Random.Range(0, 100) <totalEvasion)\n       {\n          // Debug.Log(target.transform.name + \" evades the attack.\");\n           return true;\n       }\n\n       return false;\n   }\n\n   private bool CanCrit()\n   {\n       int totalCritChance = critChance.GetValue() + agility.GetValue();\n       \n       if(Random.Range(0, 100) <= totalCritChance)\n       {\n           return true;\n       }\n       return false;\n   }\n   private int CalculateCritDamage(int totalDamage)\n   {\n       float totalCritPower = (critPower.GetValue() + strength.GetValue()) * 0.01f;\n      // Debug.Log(\"Crit power: \" + totalCritPower);\n       float critDamage = totalDamage * totalCritPower;\n      // Debug.Log(\"Crit attackPower: \" + critDamage);\n       \n       return Mathf.RoundToInt(critDamage);\n   }\n   private int CheckTargetResitane(CharacterStats target, int totalMagicDamage)\n   {\n       totalMagicDamage -= target.magicResistance.GetValue() + (target.intelligence.GetValue() * 3);\n       totalMagicDamage = Mathf.Clamp(totalMagicDamage, 0, int.MaxValue);\n       return totalMagicDamage;\n   }\n\n   \n   #endregion\n   \n   \n   public Stat GetStat(StatType _statsType)\n   {\n       switch (_statsType)\n       {\n           case StatType.strength:\n               return strength;\n           case StatType.agility:\n               return agility;\n           case StatType.intelegence:\n               return intelligence;\n           case StatType.vitality:\n               return vitality;\n           case StatType.attackPower:\n               return attackPower;\n           case StatType.critChance:\n               return critChance;\n           case StatType.critPower:\n               return critPower;\n           case StatType.armor:\n               return armor;\n           case StatType.maxHealth:\n               return maxHealth;\n           case StatType.evasion:\n               return evasion;\n           case StatType.fireDamage:\n               return fireDamage;\n           case StatType.iceDamage:\n               return iceDamage;\n           case StatType.lightningDamage:\n               return lightningDamage;\n           case StatType.magicResistance:\n               return magicResistance;\n           default:\n               return null;\n       }\n   }\n   \n   public int GetMaxHeathValue() =>  maxHealth.GetValue()  + vitality.GetValue() * 5;\n   \n   \n   \n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Status/CharacterStats.cs b/Assets/Scripts/Status/CharacterStats.cs
--- a/Assets/Scripts/Status/CharacterStats.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/Status/CharacterStats.cs	(date 1716917720360)
@@ -26,13 +26,13 @@
 {
     private EntityFX fx;
     
-    [FormerlySerializedAs("strenght")] [Header("Major stats")]
+    [Header("Major stats")]
     public Stat strength; // 1 point increase attackPower by 1 and crit.power by 1%
     public Stat agility; // 1 point increase evasion by 1% and crit.chance by 1%
-    [FormerlySerializedAs("intelegence")] public Stat intelligence; // 1 point increase magic attackPower by 1 and magic resistance by 3
+    public Stat intelligence; // 1 point increase magic attackPower by 1 and magic resistance by 3
     public Stat vitality;// 1 point increase health by 3 or 5 points
     
-    [FormerlySerializedAs("damage")] [Header("Offensive stats")]
+    [Header("Offensive stats")]
     public Stat attackPower;
     public Stat critChance;
     public Stat critPower;          // default 150% of attackPower
Index: Assets/Scripts/UI/UIItemSlot.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/UI/UIItemSlot.cs b/Assets/Scripts/UI/UIItemSlot.cs
new file mode 100644
--- /dev/null	
+++ b/Assets/Scripts/UI/UIItemSlot.cs	
@@ -0,0 +1,75 @@
+using Items_and_Inventory;
+using UnityEngine;
+using UnityEngine.UI;
+using TMPro;
+using UnityEngine.EventSystems;
+
+namespace UI
+{
+    public class UIItemSlot : MonoBehaviour, IPointerDownHandler
+    {
+        [SerializeField] private Image itemImage;
+        [SerializeField] private TextMeshProUGUI itemText;
+
+        public InventoryItem item;
+        protected UI UI;
+
+        protected void Start()
+        {
+            UI = GetComponentInParent<UI>();
+        }
+
+
+        // Clear the slot 
+        public void CleanUpSlot()
+        {
+            item = null;
+            itemImage.color = Color.clear;
+            itemImage.sprite = null;
+            itemText.text = "";
+        }
+
+        public void UpdateSlot(InventoryItem newItem)
+        {
+            item = newItem;
+
+            itemImage.color = Color.white;
+
+            if (item != null)
+            {
+                itemImage.sprite = item.data.itemIcon;
+                if (item.stackSize > 1)
+                {
+                    itemText.text = item.stackSize.ToString();
+                }
+                else
+                {
+                    itemText.text = "";
+                }
+
+            }
+        }
+
+        public virtual void OnPointerDown(PointerEventData eventData)
+        {
+
+            //Debug.Log("Equipped " + item.data.itemName);
+
+            if (item == null || item.data == null) 
+            {
+                //Debug.Log("Item, item data, or Inventory instance is null");
+                return;
+            }
+
+            if (item.data.itemType == ItemType.Equipment)
+            {
+                Inventory.Instance.EquipItem(item.data);
+                // Debug.Log("Equipped " + item.data.itemName);
+            }
+
+        }
+
+
+
+    }
+}
Index: Assets/Scripts/UI/UI.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using UnityEngine;\n\npublic class UI : MonoBehaviour\n{\n    public void Switchto(GameObject _menu)\n    {\n        for(int i = 0; i < transform.childCount; i++)\n        {\n            transform.GetChild(i).gameObject.SetActive(false);\n        }\n        \n        if(_menu != null)\n            _menu.SetActive(true);\n        \n    }\n       \n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/UI/UI.cs b/Assets/Scripts/UI/UI.cs
--- a/Assets/Scripts/UI/UI.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/UI/UI.cs	(date 1716917720360)
@@ -1,17 +1,21 @@
 using UnityEngine;
 
-public class UI : MonoBehaviour
-{
-    public void Switchto(GameObject _menu)
-    {
-        for(int i = 0; i < transform.childCount; i++)
-        {
-            transform.GetChild(i).gameObject.SetActive(false);
-        }
-        
-        if(_menu != null)
-            _menu.SetActive(true);
-        
-    }
-       
-}
+namespace UI
+{
+
+    public class UI : MonoBehaviour
+    {
+        public void Switchto(GameObject _menu)
+        {
+            for (int i = 0; i < transform.childCount; i++)
+            {
+                transform.GetChild(i).gameObject.SetActive(false);
+            }
+
+            if (_menu != null)
+                _menu.SetActive(true);
+
+        }
+
+    }
+}
\ No newline at end of file
Index: Assets/Scripts/Items and Inventory/ItemDrop.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System.Collections.Generic;\nusing UnityEngine;\n\npublic class ItemDrop : MonoBehaviour\n{   \n    [SerializeField] private int amountOfItemsToDrop;\n    [SerializeField] private ItemData[] possibleItemsDrop;\n    private List<ItemData> dropList = new List<ItemData>();\n    \n    [SerializeField] private GameObject itemObjPrefab;\n\n    public virtual void GenerateDrop()\n    {\n        for (int i = 0; i < possibleItemsDrop.Length; i++)\n        {\n            if(Random.Range(0, 100) <= possibleItemsDrop[i].dropChance)\n            {\n                dropList.Add(possibleItemsDrop[i]);\n            }\n        }\n        \n        for (int i = 0; i < amountOfItemsToDrop; i++)\n        {\n            if (dropList.Count > 0)\n            {\n                ItemData randomItem = dropList[Random.Range(0, dropList.Count )];\n                dropList.Remove(randomItem);\n                DropItem(randomItem);\n            }\n           \n           \n        }\n        \n    }\n    \n    protected void DropItem(ItemData item)\n    {\n        GameObject itemObj = Instantiate(itemObjPrefab, transform.position, Quaternion.identity);\n        Vector2 velocity = new Vector2(Random.Range(-5, 5), Random.Range(15, 20));\n        itemObj.GetComponent<itemObj>().SetupItemObj(item, velocity);\n        \n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Items and Inventory/ItemDrop.cs b/Assets/Scripts/Items and Inventory/ItemDrop.cs
--- a/Assets/Scripts/Items and Inventory/ItemDrop.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/Items and Inventory/ItemDrop.cs	(date 1716917720354)
@@ -1,43 +1,47 @@
 using System.Collections.Generic;
 using UnityEngine;
 
-public class ItemDrop : MonoBehaviour
-{   
-    [SerializeField] private int amountOfItemsToDrop;
-    [SerializeField] private ItemData[] possibleItemsDrop;
-    private List<ItemData> dropList = new List<ItemData>();
-    
-    [SerializeField] private GameObject itemObjPrefab;
+namespace Items_and_Inventory
+{
+
+    public class ItemDrop : MonoBehaviour
+    {
+        [SerializeField] private int amountOfItemsToDrop;
+        [SerializeField] private ItemData[] possibleItemsDrop;
+        private List<ItemData> _dropList = new List<ItemData>();
+
+        [SerializeField] private GameObject itemObjPrefab;
 
-    public virtual void GenerateDrop()
-    {
-        for (int i = 0; i < possibleItemsDrop.Length; i++)
-        {
-            if(Random.Range(0, 100) <= possibleItemsDrop[i].dropChance)
-            {
-                dropList.Add(possibleItemsDrop[i]);
-            }
-        }
-        
-        for (int i = 0; i < amountOfItemsToDrop; i++)
-        {
-            if (dropList.Count > 0)
-            {
-                ItemData randomItem = dropList[Random.Range(0, dropList.Count )];
-                dropList.Remove(randomItem);
-                DropItem(randomItem);
-            }
-           
-           
-        }
-        
-    }
-    
-    protected void DropItem(ItemData item)
-    {
-        GameObject itemObj = Instantiate(itemObjPrefab, transform.position, Quaternion.identity);
-        Vector2 velocity = new Vector2(Random.Range(-5, 5), Random.Range(15, 20));
-        itemObj.GetComponent<itemObj>().SetupItemObj(item, velocity);
-        
+        public virtual void GenerateDrop()
+        {
+            for (int i = 0; i < possibleItemsDrop.Length; i++)
+            {
+                if (Random.Range(0, 100) <= possibleItemsDrop[i].dropChance)
+                {
+                    _dropList.Add(possibleItemsDrop[i]);
+                }
+            }
+
+            for (int i = 0; i < amountOfItemsToDrop; i++)
+            {
+                if (_dropList.Count > 0)
+                {
+                    ItemData randomItem = _dropList[Random.Range(0, _dropList.Count)];
+                    _dropList.Remove(randomItem);
+                    DropItem(randomItem);
+                }
+
+
+            }
+
+        }
+
+        protected void DropItem(ItemData item)
+        {
+            GameObject itemObj = Instantiate(itemObjPrefab, transform.position, Quaternion.identity);
+            Vector2 velocity = new Vector2(Random.Range(-5, 5), Random.Range(15, 20));
+            itemObj.GetComponent<ItemObj>().SetupItemObj(item, velocity);
+
+        }
     }
 }
Index: Assets/Scripts/Player/Player.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Player : Entity\n{\n    [Header(\"Attack Details\")]\n    public Vector2[] attackMovement;\n    public float counterAttackDuration = .2f;\n    \n    public bool isBusy { get; private set; }\n    \n    [Header(\"Move Info\")]\n    public float moveSpeed = 10f;\n    public float jumpForce = 10f;\n    private float moveSpeedDefault;\n    private float jumpForceDefault;\n    \n    [Header(\"Dash Info\")]\n    public float dashSpeed = 13f;\n    public float dashDuration = 0.2f;\n    public float dashDirection { get; private set; }\n    public float swordReturnImpact = 10f;\n    private float dashSpeedDefault;\n    \n    \n    \n    \n    public SkillManager skillManager { get; private set; }\n    public GameObject sword {get; private set;}\n    \n    #region States\n\n    public PlayerStateMachine stateMachine { get; private set; }\n    public PlayerIdleState idleState { get; private set; }\n    public PlayerMoveState moveState { get; private set; }\n    public PlayerJumpState jumpState { get; private set; }\n    public PlayerAirState inAirState { get; private set; }\n    public PlayerDashState dashState { get; private set; }\n    public PlayerWallSlide wallSlideState { get; private set; }\n    public PlayerWallJumpState wallJumpState { get; private set; }\n    public PlayerPrimaryAttackState PrimaryAttackStateState { get; private set; }\n    public PlayerCounterAttackState counterAttackState { get; private set; }\n    public PlayerAimSwordState aimSwordState { get; private set; }\n    public PlayerCatchSwordState catchSwordState { get; private set; }\n    public PlayerBlackholeState blackholeState { get; private set; }\n    public PlayerDeadState deadState { get; private set; }\n    #endregion\n    \n    protected override void Awake()\n    {   \n        base.Awake();\n        stateMachine = gameObject.AddComponent<PlayerStateMachine>();  // stateMachine = new PlayerStateMachine();\n        idleState = new PlayerIdleState(this, stateMachine, \"Idle\");\n        moveState = new PlayerMoveState(this, stateMachine, \"Move\");\n        jumpState = new PlayerJumpState(this, stateMachine, \"Jump\");\n        inAirState = new PlayerAirState(this, stateMachine, \"Jump\");\n        dashState = new PlayerDashState(this, stateMachine, \"Dash\");\n        wallSlideState = new PlayerWallSlide(this, stateMachine, \"WallSlide\");\n        wallJumpState = new PlayerWallJumpState(this, stateMachine, \"Jump\");\n        PrimaryAttackStateState = new PlayerPrimaryAttackState(this, stateMachine, \"Attack\");\n        counterAttackState = new PlayerCounterAttackState(this, stateMachine, \"CounterAttack\");\n        \n        //sword statement\n        aimSwordState = new PlayerAimSwordState(this, stateMachine, \"AimSword\");\n        catchSwordState = new PlayerCatchSwordState(this, stateMachine, \"CatchSword\");\n        //blackhole statement\n        blackholeState = new PlayerBlackholeState(this, stateMachine, \"Jump\");\n        \n        deadState = new PlayerDeadState(this, stateMachine, \"Die\");\n    }\n\n    protected override void Start()\n    {\n        base.Start();\n        skillManager = SkillManager.instance;\n        stateMachine.Initialize(idleState);\n        \n        moveSpeedDefault = moveSpeed;\n        jumpForceDefault = jumpForce;\n        dashSpeedDefault = dashSpeed;\n        \n    }\n\n\n    protected override void Update()\n    {\n        base.Update();\n        stateMachine.CurrentState.Update();\n        CheckForDashInput();\n        //Debug.Log(\"Wall Detected: \" + IsWallDetected());    \n        //Debug.Log(\"Facing Direction: \" + facingDirection);\n        if(Input.GetKeyDown(KeyCode.F))\n            skillManager.crystalSkill.CanUseSkill();\n        \n        if(Input.GetKeyDown(KeyCode.Alpha1))\n            Inventory.instance.UseFlask();\n        \n    }\n\n\n    public override void SlowEntityBy(float slowPercentage, float duration)\n    {\n        base.SlowEntityBy(slowPercentage, duration);\n        moveSpeed = moveSpeedDefault * (1 - slowPercentage);\n        jumpForce = jumpForceDefault * (1 - slowPercentage);\n        dashSpeed = dashSpeedDefault * (1 - slowPercentage);\n        anim.speed *= (1 - slowPercentage);\n        \n        Invoke(\"ReturnDefaultSpeed\", duration);\n    }\n\n    protected override void ReturnDefaultSpeed()\n    {\n        base.ReturnDefaultSpeed();\n        moveSpeed = moveSpeedDefault;\n        jumpForce = jumpForceDefault;\n        dashSpeed = dashSpeedDefault;\n        \n    }\n\n\n    public void AssignSword(GameObject _sword)\n    {\n        sword = _sword;\n    }\n    \n    public void CatchTheSword()\n    {   \n        stateMachine.ChangeState(catchSwordState);\n        Destroy(sword);\n    }\n    \n    public IEnumerator BusyFor(float _seconds)\n    {\n        isBusy = true;\n        yield return new WaitForSeconds(_seconds);\n        isBusy = false;\n    }\n\n    \n   \n\n    public void AnimationTrigger() => stateMachine.CurrentState.AnimationFinishTrigger();\n\n\n    private void CheckForDashInput()\n    {\n        if(IsWallDetected())\n            return;\n        if(Input.GetKeyDown(KeyCode.LeftShift) && SkillManager.instance.dashSkill.CanUseSkill())\n        {\n            dashDirection = Input.GetAxisRaw(\"Horizontal\");\n            if (dashDirection == 0)\n                dashDirection = facingDirection;\n            stateMachine.ChangeState(dashState);    \n\n        }\n        \n    }\n\n    public override void Die()\n    {\n        base.Die();\n        stateMachine.ChangeState(deadState);\n    }\n   \n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Player/Player.cs b/Assets/Scripts/Player/Player.cs
--- a/Assets/Scripts/Player/Player.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/Player/Player.cs	(date 1716917720359)
@@ -1,5 +1,6 @@
 using System.Collections;
 using System.Collections.Generic;
+using Items_and_Inventory;
 using UnityEngine;
 
 public class Player : Entity
@@ -94,7 +95,7 @@
             skillManager.crystalSkill.CanUseSkill();
         
         if(Input.GetKeyDown(KeyCode.Alpha1))
-            Inventory.instance.UseFlask();
+            Inventory.Instance.UseFlask();
         
     }
 
Index: Assets/Scripts/Controllers/SkillControllers/Sword_Skill_Controller.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing Unity.VisualScripting;\nusing UnityEngine;\n\npublic class Sword_Skill_Controller : MonoBehaviour\n{   \n    \n    [SerializeField] private float returnSpeed = 10f;\n    private Animator animator;\n    private Rigidbody2D rb;\n    private Player player;\n    private CircleCollider2D circleCollider2D;\n    \n    private bool canRotate = true;\n    private bool isReturning = false;\n    \n    [Header(\"Pierce info\")]\n    [SerializeField] private float pierceForce;\n    [SerializeField] private int pierceCount;\n    \n    \n    [Header(\"Bounce info\")]\n    private float boundForce = 10f;\n    private bool isBouncing ;\n    private int amountOfBounces ;\n    private List<Transform> enemyTarget;\n    private int targetIndex;\n\n    [Header(\"Spin info\")]\n    private float maxTravelDistance;\n    private float spinDuration;\n    private float spinTimer;\n    private bool wasStopped;\n    private bool isSpinning;\n    \n    private float freezeTimeDuration;\n    \n    private float hitTimer;\n    private float hitCooldown ;\n    \n    private float spinDirection = 1;\n    \n    \n    private void Awake()\n    {\n        animator = GetComponentInChildren<Animator>();\n        rb = GetComponent<Rigidbody2D>();\n        circleCollider2D = GetComponent<CircleCollider2D>();\n        \n    }\n    \n    private void DestroyMe()\n    {\n        Destroy(gameObject);\n    }\n   \n    private void Update()\n    {\n        if(canRotate)\n            transform.right = rb.velocity.normalized;\n        if (isReturning)\n        {\n            transform.position = Vector2.MoveTowards(transform.position, player.transform.position, returnSpeed * Time.deltaTime);\n            if(Vector2.Distance(transform.position, player.transform.position) < 1f)\n                player.CatchTheSword();\n        }\n\n        BounceLogic();\n\n        SpinningLogic();\n    }\n\n    private void SpinningLogic()\n    {\n        if (isSpinning)\n        {\n            if(Vector2.Distance(player.transform.position, transform.position) > maxTravelDistance && !wasStopped)\n            {\n                StopWhenSpinning();\n            }\n\n            if (wasStopped)\n            {\n                spinTimer -= Time.deltaTime;\n                \n                // transform.position = Vector2.MoveTowards(transform.position, new Vector2(transform.position.x + spinDirection, transform.position.y), 2.4f * Time.deltaTime);\n\n                if (spinTimer < 0)\n                {\n                    isReturning = true;\n                    isSpinning = false;\n                }\n                \n                hitTimer -= Time.deltaTime;\n\n                if (hitTimer < 0)\n                {\n                    hitTimer = hitCooldown;\n\n                    Collider2D[] colliders = Physics2D.OverlapCircleAll(transform.position, 1);\n\n                    foreach (var hit in colliders)\n                    {\n                        if (hit.GetComponent<Enemy>() != null)\n                            SwordSkillDamage(hit.GetComponent<Enemy>());\n                    }\n\n                }\n            }\n        }\n        \n    }\n\n    private void StopWhenSpinning()\n    {\n        wasStopped = true;\n        rb.constraints = RigidbodyConstraints2D.FreezeAll;\n        spinTimer = spinDuration;\n    }\n\n    private void BounceLogic()\n    {\n        if (isBouncing && enemyTarget.Count > 0)\n        {\n            transform.position = Vector2.MoveTowards(transform.position, enemyTarget[targetIndex].position, boundForce * Time.deltaTime);\n            \n            if(Vector2.Distance(transform.position, enemyTarget[targetIndex].position) < 0.1f)\n            {   \n                SwordSkillDamage(enemyTarget[targetIndex].GetComponent<Enemy>());\n                //enemyTarget[targetIndex].GetComponent<Enemy>().DamageImpact();\n                //enemyTarget[targetIndex].GetComponent<Enemy>().StartCoroutine(\"FreezeTimeCoroutine\", freezeTimeDuration);\n                \n                \n                targetIndex++;\n                \n                amountOfBounces--;\n\n                if (amountOfBounces <= 0)\n                {\n                    isBouncing = false;\n                    isReturning = true;\n                }\n                \n                if (targetIndex >= enemyTarget.Count)\n                {\n                    targetIndex = 0;\n                }\n            }\n        }\n    }\n\n    private void OnTriggerEnter2D(Collider2D other)\n    {      \n        if(isReturning)\n            return;\n\n\n        if (other.GetComponent<Enemy>() != null)\n        {\n            Enemy enemy = other.GetComponent<Enemy>();\n            SwordSkillDamage(enemy);\n        }\n        \n        // other.GetComponent<Enemy>()?.DamageImpact();\n        \n        \n        \n\n        SetUpTargetForBounce(other);\n        \n        StuckInto(other);\n    }\n\n    private void SwordSkillDamage(Enemy enemy)\n    {\n        player.stats.DoDamge(enemy.GetComponent<CharacterStats>());\n        enemy.FreezeTimeFor(freezeTimeDuration);\n        \n        ItemData_Equipment equipmentAmulet = Inventory.instance.GetEquipmentType(EquipmentType.Amulet);\n        \n        if(equipmentAmulet != null)\n        {\n            equipmentAmulet.Effect(enemy.transform);\n        }\n        \n    }\n\n    private void SetUpTargetForBounce(Collider2D other)\n    {\n        if (other.GetComponent<Enemy>() != null)\n        {\n            if (isBouncing && enemyTarget.Count <= 0)\n            {\n                Collider2D[] colliders = Physics2D.OverlapCircleAll(transform.position, 10f);\n                foreach (var hit in colliders)\n                {\n                    if (hit.GetComponent<Enemy>() != null)\n                    {\n                        enemyTarget.Add(hit.transform);\n                    }\n                }\n                \n            }\n        }\n    }\n\n    public void SetUpSword(Vector2 _launchDir, float _gravityScale, Player _player, float _freezeTimeDuration, float _returnSpeed )\n    {\n        player = _player;\n        rb.gravityScale = _gravityScale;\n        rb.velocity = _launchDir;\n        if(pierceCount <= 0)\n            animator.SetBool(\"Rotation\", true);\n        spinDirection = Mathf.Clamp(rb.velocity.x, -1, 1);\n        freezeTimeDuration = _freezeTimeDuration;\n        Invoke(\"DestroyMe\", 5f);\n        \n        //animator.SetBool(\"Rotation\", true);\n    }\n\n\n    public void ReturnSword()\n    {\n        rb.constraints = RigidbodyConstraints2D.FreezeAll;\n        //rb.isKinematic = false;\n        transform.parent = null;\n        isReturning = true;\n    }\n    \n    \n    public void SetUpBounce(bool _isBouncing, int _amountOfBounces, float _boundForce)\n    {   \n        boundForce = _boundForce;\n        isBouncing = _isBouncing;\n        amountOfBounces = _amountOfBounces;\n            //boundForce = _boundForce;\n            enemyTarget = new List<Transform>();\n    }\n    \n    public void SetUpPierce(int _pierceCount)\n    {\n        pierceCount = _pierceCount;\n    }\n    \n        \n    \n    \n    public void SetUpSpin(bool _isSpinning, float _maxTravelDistance, float _spinDuration, float _hitCooldown = 0.5f)\n    {\n        isSpinning = _isSpinning;\n        maxTravelDistance = _maxTravelDistance;\n        spinDuration = _spinDuration;\n        hitCooldown = _hitCooldown;\n    }\n    \n    \n    \n    \n\n    private void StuckInto(Collider2D other)\n    {\n        if(pierceCount > 0 && other.GetComponent<Enemy>() != null)\n        {\n            pierceCount--;\n            return;\n        }\n\n        if (isSpinning)\n        {\n            StopWhenSpinning();\n            return;\n        }\n        \n        canRotate = false;\n        circleCollider2D.enabled = false;\n        \n        rb.isKinematic = true;\n        rb.constraints = RigidbodyConstraints2D.FreezeAll;\n        \n        if(isBouncing && enemyTarget.Count > 0)\n            return;\n        \n        transform.parent = other.transform;\n        animator.SetBool(\"Rotation\", false);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Controllers/SkillControllers/Sword_Skill_Controller.cs b/Assets/Scripts/Controllers/SkillControllers/Sword_Skill_Controller.cs
--- a/Assets/Scripts/Controllers/SkillControllers/Sword_Skill_Controller.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/Controllers/SkillControllers/Sword_Skill_Controller.cs	(date 1716917720352)
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Items_and_Inventory;
 using Unity.VisualScripting;
 using UnityEngine;
 
@@ -178,7 +179,7 @@
         player.stats.DoDamge(enemy.GetComponent<CharacterStats>());
         enemy.FreezeTimeFor(freezeTimeDuration);
         
-        ItemData_Equipment equipmentAmulet = Inventory.instance.GetEquipmentType(EquipmentType.Amulet);
+        ItemData_Equipment equipmentAmulet = Inventory.Instance.GetEquipmentType(EquipmentType.Amulet);
         
         if(equipmentAmulet != null)
         {
Index: Assets/Scenes/SampleScene.unity
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scenes/SampleScene.unity b/Assets/Scenes/SampleScene.unity
--- a/Assets/Scenes/SampleScene.unity	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scenes/SampleScene.unity	(date 1716917720349)
@@ -4303,7 +4303,7 @@
   m_EditorClassIdentifier: 
   m_Material: {fileID: 0}
   m_Color: {r: 1, g: 1, b: 1, a: 1}
-  m_RaycastTarget: 1
+  m_RaycastTarget: 0
   m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
   m_Maskable: 1
   m_OnCullStateChanged:
@@ -5286,6 +5286,7 @@
   m_Children:
   - {fileID: 103786740}
   - {fileID: 2030255564}
+  - {fileID: 1274233482}
   m_Father: {fileID: 1416268697}
   m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
   m_AnchorMin: {x: 0, y: 0}
@@ -5305,7 +5306,7 @@
   m_Script: {fileID: 11500000, guid: 7234fb6ee522a459d89f85ff4801ffdb, type: 3}
   m_Name: 
   m_EditorClassIdentifier: 
-  itemImage: {fileID: 2030255565}
+  itemImage: {fileID: 1274233483}
   itemText: {fileID: 103786741}
   item:
     data: {fileID: 0}
@@ -5504,6 +5505,81 @@
   m_PrefabInstance: {fileID: 0}
   m_PrefabAsset: {fileID: 0}
   m_GameObject: {fileID: 883517964}
+  m_CullTransparentMesh: 1
+--- !u!1 &896733683
+GameObject:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  serializedVersion: 6
+  m_Component:
+  - component: {fileID: 896733684}
+  - component: {fileID: 896733686}
+  - component: {fileID: 896733685}
+  m_Layer: 5
+  m_Name: Image
+  m_TagString: Untagged
+  m_Icon: {fileID: 0}
+  m_NavMeshLayer: 0
+  m_StaticEditorFlags: 0
+  m_IsActive: 1
+--- !u!224 &896733684
+RectTransform:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 896733683}
+  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
+  m_LocalPosition: {x: 0, y: 0, z: 0}
+  m_LocalScale: {x: 1, y: 1, z: 1}
+  m_ConstrainProportionsScale: 0
+  m_Children: []
+  m_Father: {fileID: 985573231459337029}
+  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
+  m_AnchorMin: {x: 0.5, y: 0.5}
+  m_AnchorMax: {x: 0.5, y: 0.5}
+  m_AnchoredPosition: {x: 0, y: 0}
+  m_SizeDelta: {x: 100, y: 100}
+  m_Pivot: {x: 0.5, y: 0.5}
+--- !u!114 &896733685
+MonoBehaviour:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 896733683}
+  m_Enabled: 1
+  m_EditorHideFlags: 0
+  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
+  m_Name: 
+  m_EditorClassIdentifier: 
+  m_Material: {fileID: 0}
+  m_Color: {r: 1, g: 1, b: 1, a: 1}
+  m_RaycastTarget: 1
+  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
+  m_Maskable: 1
+  m_OnCullStateChanged:
+    m_PersistentCalls:
+      m_Calls: []
+  m_Sprite: {fileID: -34813010, guid: 2edbdc6eb6e4b41a28c3595bf272f002, type: 3}
+  m_Type: 1
+  m_PreserveAspect: 0
+  m_FillCenter: 1
+  m_FillMethod: 4
+  m_FillAmount: 1
+  m_FillClockwise: 1
+  m_FillOrigin: 0
+  m_UseSpriteMesh: 0
+  m_PixelsPerUnitMultiplier: 1
+--- !u!222 &896733686
+CanvasRenderer:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 896733683}
   m_CullTransparentMesh: 1
 --- !u!1001 &897719963
 PrefabInstance:
@@ -5988,6 +6064,7 @@
   m_Children:
   - {fileID: 1136232492}
   - {fileID: 599000308}
+  - {fileID: 1104639882}
   m_Father: {fileID: 1416268697}
   m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
   m_AnchorMin: {x: 0, y: 0}
@@ -6007,7 +6084,7 @@
   m_Script: {fileID: 11500000, guid: 7234fb6ee522a459d89f85ff4801ffdb, type: 3}
   m_Name: 
   m_EditorClassIdentifier: 
-  itemImage: {fileID: 599000309}
+  itemImage: {fileID: 1104639883}
   itemText: {fileID: 1136232493}
   item:
     data: {fileID: 0}
@@ -7020,6 +7097,7 @@
   m_Children:
   - {fileID: 825677844}
   - {fileID: 841400633}
+  - {fileID: 1873982816}
   m_Father: {fileID: 1416268697}
   m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
   m_AnchorMin: {x: 0, y: 0}
@@ -7039,7 +7117,7 @@
   m_Script: {fileID: 11500000, guid: 7234fb6ee522a459d89f85ff4801ffdb, type: 3}
   m_Name: 
   m_EditorClassIdentifier: 
-  itemImage: {fileID: 841400634}
+  itemImage: {fileID: 1873982817}
   itemText: {fileID: 825677845}
   item:
     data: {fileID: 0}
@@ -7715,6 +7793,156 @@
   m_PrefabInstance: {fileID: 0}
   m_PrefabAsset: {fileID: 0}
   m_GameObject: {fileID: 1077217822}
+  m_CullTransparentMesh: 1
+--- !u!1 &1080987122
+GameObject:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  serializedVersion: 6
+  m_Component:
+  - component: {fileID: 1080987123}
+  - component: {fileID: 1080987125}
+  - component: {fileID: 1080987124}
+  m_Layer: 5
+  m_Name: Image
+  m_TagString: Untagged
+  m_Icon: {fileID: 0}
+  m_NavMeshLayer: 0
+  m_StaticEditorFlags: 0
+  m_IsActive: 1
+--- !u!224 &1080987123
+RectTransform:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 1080987122}
+  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
+  m_LocalPosition: {x: 0, y: 0, z: 0}
+  m_LocalScale: {x: 1, y: 1, z: 1}
+  m_ConstrainProportionsScale: 0
+  m_Children: []
+  m_Father: {fileID: 985573231459337029}
+  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
+  m_AnchorMin: {x: 0.5, y: 0.5}
+  m_AnchorMax: {x: 0.5, y: 0.5}
+  m_AnchoredPosition: {x: 0, y: -1}
+  m_SizeDelta: {x: 75.341, y: 75.341}
+  m_Pivot: {x: 0.5, y: 0.5}
+--- !u!114 &1080987124
+MonoBehaviour:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 1080987122}
+  m_Enabled: 1
+  m_EditorHideFlags: 0
+  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
+  m_Name: 
+  m_EditorClassIdentifier: 
+  m_Material: {fileID: 0}
+  m_Color: {r: 1, g: 1, b: 1, a: 0}
+  m_RaycastTarget: 1
+  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
+  m_Maskable: 1
+  m_OnCullStateChanged:
+    m_PersistentCalls:
+      m_Calls: []
+  m_Sprite: {fileID: 0}
+  m_Type: 0
+  m_PreserveAspect: 0
+  m_FillCenter: 1
+  m_FillMethod: 4
+  m_FillAmount: 1
+  m_FillClockwise: 1
+  m_FillOrigin: 0
+  m_UseSpriteMesh: 0
+  m_PixelsPerUnitMultiplier: 1
+--- !u!222 &1080987125
+CanvasRenderer:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 1080987122}
+  m_CullTransparentMesh: 1
+--- !u!1 &1104639881
+GameObject:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  serializedVersion: 6
+  m_Component:
+  - component: {fileID: 1104639882}
+  - component: {fileID: 1104639884}
+  - component: {fileID: 1104639883}
+  m_Layer: 5
+  m_Name: Image (2)
+  m_TagString: Untagged
+  m_Icon: {fileID: 0}
+  m_NavMeshLayer: 0
+  m_StaticEditorFlags: 0
+  m_IsActive: 1
+--- !u!224 &1104639882
+RectTransform:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 1104639881}
+  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
+  m_LocalPosition: {x: 0, y: 0, z: 0}
+  m_LocalScale: {x: 1, y: 1, z: 1}
+  m_ConstrainProportionsScale: 0
+  m_Children: []
+  m_Father: {fileID: 942327968}
+  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
+  m_AnchorMin: {x: 0.5, y: 0.5}
+  m_AnchorMax: {x: 0.5, y: 0.5}
+  m_AnchoredPosition: {x: 0, y: -0}
+  m_SizeDelta: {x: 75.341, y: 75.341}
+  m_Pivot: {x: 0.5, y: 0.5}
+--- !u!114 &1104639883
+MonoBehaviour:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 1104639881}
+  m_Enabled: 1
+  m_EditorHideFlags: 0
+  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
+  m_Name: 
+  m_EditorClassIdentifier: 
+  m_Material: {fileID: 0}
+  m_Color: {r: 1, g: 1, b: 1, a: 0}
+  m_RaycastTarget: 1
+  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
+  m_Maskable: 1
+  m_OnCullStateChanged:
+    m_PersistentCalls:
+      m_Calls: []
+  m_Sprite: {fileID: 0}
+  m_Type: 0
+  m_PreserveAspect: 0
+  m_FillCenter: 1
+  m_FillMethod: 4
+  m_FillAmount: 1
+  m_FillClockwise: 1
+  m_FillOrigin: 0
+  m_UseSpriteMesh: 0
+  m_PixelsPerUnitMultiplier: 1
+--- !u!222 &1104639884
+CanvasRenderer:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 1104639881}
   m_CullTransparentMesh: 1
 --- !u!1 &1105005495
 GameObject:
@@ -9816,6 +10044,81 @@
     m_AddedGameObjects: []
     m_AddedComponents: []
   m_SourcePrefab: {fileID: 100100000, guid: 0299fc85ee73c4b8a95c32970fc588a3, type: 3}
+--- !u!1 &1274233481
+GameObject:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  serializedVersion: 6
+  m_Component:
+  - component: {fileID: 1274233482}
+  - component: {fileID: 1274233484}
+  - component: {fileID: 1274233483}
+  m_Layer: 5
+  m_Name: Image (3)
+  m_TagString: Untagged
+  m_Icon: {fileID: 0}
+  m_NavMeshLayer: 0
+  m_StaticEditorFlags: 0
+  m_IsActive: 1
+--- !u!224 &1274233482
+RectTransform:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 1274233481}
+  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
+  m_LocalPosition: {x: 0, y: 0, z: 0}
+  m_LocalScale: {x: 1, y: 1, z: 1}
+  m_ConstrainProportionsScale: 0
+  m_Children: []
+  m_Father: {fileID: 877123627}
+  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
+  m_AnchorMin: {x: 0.5, y: 0.5}
+  m_AnchorMax: {x: 0.5, y: 0.5}
+  m_AnchoredPosition: {x: -1, y: 4}
+  m_SizeDelta: {x: 75.341, y: 75.341}
+  m_Pivot: {x: 0.5, y: 0.5}
+--- !u!114 &1274233483
+MonoBehaviour:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 1274233481}
+  m_Enabled: 1
+  m_EditorHideFlags: 0
+  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
+  m_Name: 
+  m_EditorClassIdentifier: 
+  m_Material: {fileID: 0}
+  m_Color: {r: 1, g: 1, b: 1, a: 0}
+  m_RaycastTarget: 1
+  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
+  m_Maskable: 1
+  m_OnCullStateChanged:
+    m_PersistentCalls:
+      m_Calls: []
+  m_Sprite: {fileID: 0}
+  m_Type: 0
+  m_PreserveAspect: 0
+  m_FillCenter: 1
+  m_FillMethod: 4
+  m_FillAmount: 1
+  m_FillClockwise: 1
+  m_FillOrigin: 0
+  m_UseSpriteMesh: 0
+  m_PixelsPerUnitMultiplier: 1
+--- !u!222 &1274233484
+CanvasRenderer:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 1274233481}
+  m_CullTransparentMesh: 1
 --- !u!1 &1281811191
 GameObject:
   m_ObjectHideFlags: 0
@@ -10525,81 +10828,6 @@
   m_CorrespondingSourceObject: {fileID: 5875503770237378161, guid: 0299fc85ee73c4b8a95c32970fc588a3, type: 3}
   m_PrefabInstance: {fileID: 236237535}
   m_PrefabAsset: {fileID: 0}
---- !u!1 &1354870713
-GameObject:
-  m_ObjectHideFlags: 0
-  m_CorrespondingSourceObject: {fileID: 0}
-  m_PrefabInstance: {fileID: 0}
-  m_PrefabAsset: {fileID: 0}
-  serializedVersion: 6
-  m_Component:
-  - component: {fileID: 1354870714}
-  - component: {fileID: 1354870716}
-  - component: {fileID: 1354870715}
-  m_Layer: 5
-  m_Name: Image
-  m_TagString: Untagged
-  m_Icon: {fileID: 0}
-  m_NavMeshLayer: 0
-  m_StaticEditorFlags: 0
-  m_IsActive: 1
---- !u!224 &1354870714
-RectTransform:
-  m_ObjectHideFlags: 0
-  m_CorrespondingSourceObject: {fileID: 0}
-  m_PrefabInstance: {fileID: 0}
-  m_PrefabAsset: {fileID: 0}
-  m_GameObject: {fileID: 1354870713}
-  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
-  m_LocalPosition: {x: 0, y: 0, z: 0}
-  m_LocalScale: {x: 1, y: 1, z: 1}
-  m_ConstrainProportionsScale: 0
-  m_Children: []
-  m_Father: {fileID: 985573231459337029}
-  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
-  m_AnchorMin: {x: 0.5, y: 0.5}
-  m_AnchorMax: {x: 0.5, y: 0.5}
-  m_AnchoredPosition: {x: 0.000061035156, y: 0}
-  m_SizeDelta: {x: 100, y: 100}
-  m_Pivot: {x: 0.5, y: 0.5}
---- !u!114 &1354870715
-MonoBehaviour:
-  m_ObjectHideFlags: 0
-  m_CorrespondingSourceObject: {fileID: 0}
-  m_PrefabInstance: {fileID: 0}
-  m_PrefabAsset: {fileID: 0}
-  m_GameObject: {fileID: 1354870713}
-  m_Enabled: 1
-  m_EditorHideFlags: 0
-  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
-  m_Name: 
-  m_EditorClassIdentifier: 
-  m_Material: {fileID: 0}
-  m_Color: {r: 1, g: 1, b: 1, a: 1}
-  m_RaycastTarget: 1
-  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
-  m_Maskable: 1
-  m_OnCullStateChanged:
-    m_PersistentCalls:
-      m_Calls: []
-  m_Sprite: {fileID: -34813010, guid: 2edbdc6eb6e4b41a28c3595bf272f002, type: 3}
-  m_Type: 1
-  m_PreserveAspect: 0
-  m_FillCenter: 1
-  m_FillMethod: 4
-  m_FillAmount: 1
-  m_FillClockwise: 1
-  m_FillOrigin: 0
-  m_UseSpriteMesh: 0
-  m_PixelsPerUnitMultiplier: 1
---- !u!222 &1354870716
-CanvasRenderer:
-  m_ObjectHideFlags: 0
-  m_CorrespondingSourceObject: {fileID: 0}
-  m_PrefabInstance: {fileID: 0}
-  m_PrefabAsset: {fileID: 0}
-  m_GameObject: {fileID: 1354870713}
-  m_CullTransparentMesh: 1
 --- !u!1001 &1355479136
 PrefabInstance:
   m_ObjectHideFlags: 0
@@ -11086,7 +11314,7 @@
   m_PrefabInstance: {fileID: 0}
   m_PrefabAsset: {fileID: 0}
   m_GameObject: {fileID: 1416268696}
-  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
+  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
   m_LocalPosition: {x: 0, y: 0, z: 0}
   m_LocalScale: {x: 1, y: 1, z: 1}
   m_ConstrainProportionsScale: 0
@@ -11117,7 +11345,7 @@
   m_EditorClassIdentifier: 
   m_Material: {fileID: 0}
   m_Color: {r: 1, g: 1, b: 1, a: 1}
-  m_RaycastTarget: 1
+  m_RaycastTarget: 0
   m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
   m_Maskable: 1
   m_OnCullStateChanged:
@@ -14844,6 +15072,81 @@
   m_CorrespondingSourceObject: {fileID: 5176659580832269202, guid: e9de7fe13f2cb9d4ea4e061987dcda5f, type: 3}
   m_PrefabInstance: {fileID: 1872405142}
   m_PrefabAsset: {fileID: 0}
+--- !u!1 &1873982815
+GameObject:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  serializedVersion: 6
+  m_Component:
+  - component: {fileID: 1873982816}
+  - component: {fileID: 1873982818}
+  - component: {fileID: 1873982817}
+  m_Layer: 5
+  m_Name: Image (1)
+  m_TagString: Untagged
+  m_Icon: {fileID: 0}
+  m_NavMeshLayer: 0
+  m_StaticEditorFlags: 0
+  m_IsActive: 1
+--- !u!224 &1873982816
+RectTransform:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 1873982815}
+  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
+  m_LocalPosition: {x: 0, y: 0, z: 0}
+  m_LocalScale: {x: 1, y: 1, z: 1}
+  m_ConstrainProportionsScale: 0
+  m_Children: []
+  m_Father: {fileID: 1052899023}
+  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
+  m_AnchorMin: {x: 0.5, y: 0.5}
+  m_AnchorMax: {x: 0.5, y: 0.5}
+  m_AnchoredPosition: {x: -3, y: 2}
+  m_SizeDelta: {x: 75.341, y: 75.341}
+  m_Pivot: {x: 0.5, y: 0.5}
+--- !u!114 &1873982817
+MonoBehaviour:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 1873982815}
+  m_Enabled: 1
+  m_EditorHideFlags: 0
+  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
+  m_Name: 
+  m_EditorClassIdentifier: 
+  m_Material: {fileID: 0}
+  m_Color: {r: 1, g: 1, b: 1, a: 0}
+  m_RaycastTarget: 1
+  m_RaycastPadding: {x: 0, y: 0, z: 0, w: 0}
+  m_Maskable: 1
+  m_OnCullStateChanged:
+    m_PersistentCalls:
+      m_Calls: []
+  m_Sprite: {fileID: 0}
+  m_Type: 0
+  m_PreserveAspect: 0
+  m_FillCenter: 1
+  m_FillMethod: 4
+  m_FillAmount: 1
+  m_FillClockwise: 1
+  m_FillOrigin: 0
+  m_UseSpriteMesh: 0
+  m_PixelsPerUnitMultiplier: 1
+--- !u!222 &1873982818
+CanvasRenderer:
+  m_ObjectHideFlags: 0
+  m_CorrespondingSourceObject: {fileID: 0}
+  m_PrefabInstance: {fileID: 0}
+  m_PrefabAsset: {fileID: 0}
+  m_GameObject: {fileID: 1873982815}
+  m_CullTransparentMesh: 1
 --- !u!1 &1874126853
 GameObject:
   m_ObjectHideFlags: 0
@@ -21026,7 +21329,8 @@
   m_ConstrainProportionsScale: 0
   m_Children:
   - {fileID: 2088383069003967953}
-  - {fileID: 1354870714}
+  - {fileID: 896733684}
+  - {fileID: 1080987123}
   m_Father: {fileID: 1416268697}
   m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
   m_AnchorMin: {x: 0, y: 0}
@@ -21427,7 +21731,7 @@
   m_Script: {fileID: 11500000, guid: 7234fb6ee522a459d89f85ff4801ffdb, type: 3}
   m_Name: 
   m_EditorClassIdentifier: 
-  itemImage: {fileID: 1354870715}
+  itemImage: {fileID: 1080987124}
   itemText: {fileID: 8231293584194038784}
   item:
     data: {fileID: 0}
Index: Assets/Scripts/UI/UIEquipmentSlot.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/UI/UIEquipmentSlot.cs b/Assets/Scripts/UI/UIEquipmentSlot.cs
new file mode 100644
--- /dev/null	
+++ b/Assets/Scripts/UI/UIEquipmentSlot.cs	
@@ -0,0 +1,29 @@
+using Items_and_Inventory;
+using UnityEngine;
+using UnityEngine.EventSystems;
+
+namespace UI
+{
+
+   public class UIEquipmentSlot : UIItemSlot
+   {
+      public EquipmentType slotType;
+
+      private void OnValidate()
+      {
+         gameObject.name = "Equipment slot - " + slotType.ToString();
+      }
+
+      public override void OnPointerDown(PointerEventData eventData)
+      {
+
+         if (item == null || item.data == null || Inventory.Instance == null)
+            return;
+
+         Inventory.Instance.UnEquipItem(item.data as ItemData_Equipment);
+         Inventory.Instance.AddItem(item.data as ItemData_Equipment);
+         CleanUpSlot();
+
+      }
+   }
+}
\ No newline at end of file
Index: Assets/Scripts/Controllers/SkillControllers/Crystal_Skill_Controller.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using Unity.VisualScripting;\nusing UnityEngine;\nusing Plane = System.Numerics.Plane;\n\npublic class Crystal_Skill_Controller : MonoBehaviour\n{\n    private Animator animator => GetComponent<Animator>();\n    private CircleCollider2D circleCollider2D => GetComponent<CircleCollider2D>();\n    \n    private Player player;\n    \n    private bool canGrow;\n    private float growSpeed = 5;\n    \n    private float crystalExistTimer;\n    \n    \n    private bool canExplode;\n    private bool canMoveToEnemy;\n    private float crystalSpeed;\n    \n    private Transform closestTarget;\n    [SerializeField] private LayerMask enemyLayer;\n   \n    \n    public void SetupCrystal(float timeToExist, bool canExplode, bool canMoveToEnemy, float crystalSpeed, Transform _closestTarget, Player _player)\n    {\n        crystalExistTimer = timeToExist;\n        this.canExplode = canExplode;\n        this.canMoveToEnemy = canMoveToEnemy;\n        this.crystalSpeed = crystalSpeed;\n        closestTarget = _closestTarget;\n        player = _player;\n    }\n   \n    \n    public void ChooseRandomEnemy()\n    {\n        float radius = SkillManager.instance.blackholeSkill.GetBlackholeRadius();\n        Collider2D[] enemies = Physics2D.OverlapCircleAll(transform.position, radius, enemyLayer);\n        //closestEnemy = enemies[Random.Range(0, enemies.Length)].transform;\n        if(enemies.Length > 0)\n            closestTarget = enemies[Random.Range(0, enemies.Length)].transform;\n        \n    }\n    \n    private void Update()\n    {   \n        crystalExistTimer -= Time.deltaTime;\n        \n        if (crystalExistTimer < 0)\n        {\n            FinishCrystal();\n        }\n\n        //flip crystal to enemy\n        FlipCrystalToEnemy();\n        \n        if (canMoveToEnemy)\n        {   \n            if(closestTarget == null)\n                return;\n            //RotateCrystalToEnemy();\n            transform.position = Vector2.MoveTowards(transform.position, closestTarget.position, crystalSpeed * Time.deltaTime);\n            if (Vector2.Distance(transform.position, closestTarget.position) < 1)\n            { \n                FinishCrystal();\n                canMoveToEnemy = false;\n            }\n        }\n        \n        if(canGrow)\n            transform.localScale = Vector2.Lerp(transform.localScale, Vector2.one, growSpeed * Time.deltaTime);\n    }\n    \n    \n    //Flip and rotate crystal to enemy\n    private void FlipCrystalToEnemy()\n    {   \n        if (closestTarget == null)\n            return;\n        Vector2 direction = closestTarget.position - transform.position;\n        float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;\n        transform.rotation = Quaternion.AngleAxis(angle, Vector3.forward);\n    }\n    \n\n    public void FinishCrystal()\n    {\n        if (canExplode)\n        {\n           // Debug.Log(\"Explode\");\n            canGrow = true;\n            animator.SetTrigger(\"Explode\");\n        }\n        else\n        {\n            SelfDestroy();\n        }\n    }\n\n    private void AnimationExplodeEnd()\n    {\n        Collider2D[] collider = Physics2D.OverlapCircleAll(transform.position, circleCollider2D.radius);\n        foreach (var hit in collider)\n        {\n            if (hit.GetComponent<Enemy>() != null)\n            {\n                player.stats.DoMagicDamage(hit.GetComponent<CharacterStats>());\n                \n                ItemData_Equipment equipmentAmulet = Inventory.instance.GetEquipmentType(EquipmentType.Amulet) as ItemData_Equipment;\n                if (equipmentAmulet != null)\n                {\n                    equipmentAmulet.Effect(hit.transform);\n                }\n            }\n        }\n        \n    }\n    \n    public void SelfDestroy() => Destroy(gameObject);\n    \n   \n   \n   \n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Controllers/SkillControllers/Crystal_Skill_Controller.cs b/Assets/Scripts/Controllers/SkillControllers/Crystal_Skill_Controller.cs
--- a/Assets/Scripts/Controllers/SkillControllers/Crystal_Skill_Controller.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/Controllers/SkillControllers/Crystal_Skill_Controller.cs	(date 1716917720352)
@@ -1,3 +1,4 @@
+using Items_and_Inventory;
 using Unity.VisualScripting;
 using UnityEngine;
 using Plane = System.Numerics.Plane;
@@ -108,7 +109,7 @@
             {
                 player.stats.DoMagicDamage(hit.GetComponent<CharacterStats>());
                 
-                ItemData_Equipment equipmentAmulet = Inventory.instance.GetEquipmentType(EquipmentType.Amulet) as ItemData_Equipment;
+                ItemData_Equipment equipmentAmulet = Inventory.Instance.GetEquipmentType(EquipmentType.Amulet) as ItemData_Equipment;
                 if (equipmentAmulet != null)
                 {
                     equipmentAmulet.Effect(hit.transform);
Index: Assets/TextMesh Pro/Examples & Extras/Scripts/ShaderPropAnimator.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>using UnityEngine;\nusing System.Collections;\n\n\nnamespace TMPro.Examples\n{\n    \n    public class ShaderPropAnimator : MonoBehaviour\n    {\n\n        private Renderer m_Renderer;\n        private Material m_Material;\n\n        public AnimationCurve GlowCurve;\n\n        public float m_frame;\n\n        void Awake()\n        {\n            // Cache a reference to object's renderer\n            m_Renderer = GetComponent<Renderer>();\n\n            // Cache a reference to object's material and create an instance by doing so.\n            m_Material = m_Renderer.material;\n        }\n\n        void Start()\n        {\n            StartCoroutine(AnimateProperties());\n        }\n\n        IEnumerator AnimateProperties()\n        {\n            //float lightAngle;\n            float glowPower;\n            m_frame = Random.Range(0f, 1f);\n\n            while (true)\n            {\n                //lightAngle = (m_Material.GetFloat(ShaderPropertyIDs.ID_LightAngle) + Time.deltaTime) % 6.2831853f;\n                //m_Material.SetFloat(ShaderPropertyIDs.ID_LightAngle, lightAngle);\n\n                glowPower = GlowCurve.Evaluate(m_frame);\n                m_Material.SetFloat(ShaderUtilities.ID_GlowPower, glowPower);\n\n                m_frame += Time.deltaTime * Random.Range(0.2f, 0.3f);\n                yield return new WaitForEndOfFrame();\n            }\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/TextMesh Pro/Examples & Extras/Scripts/ShaderPropAnimator.cs b/Assets/TextMesh Pro/Examples & Extras/Scripts/ShaderPropAnimator.cs
--- a/Assets/TextMesh Pro/Examples & Extras/Scripts/ShaderPropAnimator.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/TextMesh Pro/Examples & Extras/Scripts/ShaderPropAnimator.cs	(date 1716917720364)
@@ -20,7 +20,7 @@
             // Cache a reference to object's renderer
             m_Renderer = GetComponent<Renderer>();
 
-            // Cache a reference to object's material and create an instance by doing so.
+            // Cache a reference to object's material and create an Instance by doing so.
             m_Material = m_Renderer.material;
         }
 
Index: Assets/Scripts/Player/State/PlayerAnimationTriggers.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\nusing UnityEngine;\n\npublic class PlayerAnimationTriggers : MonoBehaviour\n{\n   private Player player => GetComponentInParent<Player>();\n   \n   private void AnimationTrigger()\n   {\n       player.AnimationTrigger();\n   }\n   \n   private void AttackTriggers()\n   {\n       Collider2D[] collider2Ds = Physics2D.OverlapCircleAll(player.attackCheck.position, player.attackCheckRadius);\n\n       foreach (var hit in collider2Ds)\n       {\n           if (hit.GetComponent<Enemy>() != null)\n           {\n               EnemyStats _target = hit.GetComponent<EnemyStats>();\n               \n               if(_target != null)\n                   player.stats.DoDamge(_target);\n               \n               ItemData_Equipment weaponData = Inventory.instance.GetEquipmentType(EquipmentType.Weapon);\n\n               if (weaponData != null)\n               {\n                   weaponData.Effect(_target.transform);\n               }\n           }\n       }\n       \n   }\n   \n   private void ThrowSword()\n   {\n       SkillManager.instance.swordSkill.CreateSword();\n   }\n   \n   \n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/Player/State/PlayerAnimationTriggers.cs b/Assets/Scripts/Player/State/PlayerAnimationTriggers.cs
--- a/Assets/Scripts/Player/State/PlayerAnimationTriggers.cs	(revision 2daa4b2d540bb18db498ec3b5a77a86216bc0dbe)
+++ b/Assets/Scripts/Player/State/PlayerAnimationTriggers.cs	(date 1716917720359)
@@ -1,4 +1,5 @@
 
+using Items_and_Inventory;
 using UnityEngine;
 
 public class PlayerAnimationTriggers : MonoBehaviour
@@ -23,7 +24,7 @@
                if(_target != null)
                    player.stats.DoDamge(_target);
                
-               ItemData_Equipment weaponData = Inventory.instance.GetEquipmentType(EquipmentType.Weapon);
+               ItemData_Equipment weaponData = Inventory.Instance.GetEquipmentType(EquipmentType.Weapon);
 
                if (weaponData != null)
                {
Index: Assets/Scripts/UI/UICraftSlot.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assets/Scripts/UI/UICraftSlot.cs b/Assets/Scripts/UI/UICraftSlot.cs
new file mode 100644
--- /dev/null	
+++ b/Assets/Scripts/UI/UICraftSlot.cs	
@@ -0,0 +1,22 @@
+using System;
+using Items_and_Inventory;
+using UnityEngine;
+using UnityEngine.EventSystems;
+
+namespace UI
+{
+   public class UICraftSlot : UIItemSlot
+   {
+      private void OnEnable()
+      {
+         UpdateSlot(item);
+      }
+
+      public override void OnPointerDown(PointerEventData eventData)
+      {
+         ItemData_Equipment crafData = item.data as ItemData_Equipment;
+         Inventory.Instance.CanCraft(crafData, crafData.craftingMaterials);
+
+      }
+   }
+}
\ No newline at end of file
diff --git a/Assets/Scripts/UI/UI_ItemSlot.cs.meta b/Assets/Scripts/UI/UIItemSlot.cs.meta
rename from Assets/Scripts/UI/UI_ItemSlot.cs.meta
rename to Assets/Scripts/UI/UIItemSlot.cs.meta
diff --git a/Assets/Scripts/UI/UI_CraftSlot.cs.meta b/Assets/Scripts/UI/UICraftSlot.cs.meta
rename from Assets/Scripts/UI/UI_CraftSlot.cs.meta
rename to Assets/Scripts/UI/UICraftSlot.cs.meta
diff --git a/Assets/Scripts/UI/UI_EquipmentSlot.cs.meta b/Assets/Scripts/UI/UIEquipmentSlot.cs.meta
rename from Assets/Scripts/UI/UI_EquipmentSlot.cs.meta
rename to Assets/Scripts/UI/UIEquipmentSlot.cs.meta
